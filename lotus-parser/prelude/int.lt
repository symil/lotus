export type(i32) int {
    add(int) -> int {{ i32.add }}
    sub(int) -> int {{ i32.sub }}
    mul(int) -> int {{ i32.mul }}
    div(int) -> int {{ i32.div_s }}
    mod(int) -> int {{ i32.rem_s }}
    shl(int) -> int {{ i32.shl }}
    shr(int) -> int {{ i32.shr_u }}
    and(int) -> int {{ i32.and }}
    or(int) -> int {{ i32.or }}
    xor(int) -> int {{ i32.xor }}
    eq(int) -> bool {{ i32.eq }}
    ne(int) -> bool {{ i32.ne }}
    ge(int) -> bool {{ i32.ge_s }}
    gt(int) -> bool {{ i32.gt_s }}
    le(int) -> bool {{ i32.le_s }}
    lt(int) -> bool {{ i32.lt_s }}
    not() -> int {{ (i32.xor (i32.const 0xffffffff)) }}
    plus() -> int {{ }}
    minus() -> int {{ (i32.mul (i32.const -1)) }}

    clz() -> int {{ i32.clz }}
    ctz() -> int {{ i32.ctz }}
    as_float() -> float {{ f32.reinterpret_i32 }}
    to_float() -> float {{ f32.convert_i32_s }}
    to_bool() -> bool {{ (i32.eqz i32.eqz) }}
    to_char() -> char {{ }}

    print() {{ (call $__log_int) }}

    static __default() -> int {{
        (i32.const 0)
    }}

    static __none() -> int {{
        (i32.const -2147483648)
    }}

    __is_none() -> bool {{
        (i32.const -2147483648)
        (i32.eq)
    }}

    static __chosen() -> int {
        return 23;
    }

    min(other: int) -> int {
        if this < other {
            return this;
        } else {
            return other;
        }
    }

    max(other: int) -> int {
        if this > other {
            return this;
        } else {
            return other;
        }
    }

    to_hexa_string() -> string {
        return "0x" + int_to_string(this, 16).pad_start('0', 8);
    }

    to_string() -> string {
        return int_to_string(this, 10);
    }

    to_debug_string(set: Set<ptr>) -> string {
        return this.to_string();
    }

    log(base: int) -> int {
        if this < 1 {
            return 1;
        }

        let n = this;
        let result = 0;

        while n > 0 {
            result += 1;
            n /= base;
        }

        return result;
    }
    
    log2() -> int {
        if this < 2 {
            return 1;
        } else {
            return 32 - (this - 1).clz();
        }
    }

    next_power_of_2() -> int {
        return 1 << this.log2();
    }

    log4() -> int {
        if this < 4 {
            return 1;
        } else {
            return (33 - (this - 1).clz()) / 2;
        }
    }

    next_power_of_4() -> int {
        return 1 << (this.log4() * 2);
    }

    pow(exponent: int) -> int {
        let result = 1;

        while exponent > 0 {
            result = result * this;
            exponent = exponent - 1;
        }

        return result;
    }

    // https://github.com/nodejs/node/blob/238104c531219db05e3421521c305404ce0c0cce/deps/v8/src/utils/utils.h#L213
    __hash() -> int {
        let hash = this;

        hash = ~hash + (hash << 15);
        hash = hash ^ (hash >> 12);
        hash = hash + (hash << 2);
        hash = hash ^ (hash >> 4);
        hash = hash * 2057;
        hash = hash ^ (hash >> 16);

        return hash & 0x3fffffff;
    }
}

fn get_char(n: int) -> char {
    if n < 10 {
        return ('0'.to_int() + n).to_char();
    } else {
        return ('A'.to_int() + (n - 10)).to_char();
    }
}

fn int_to_string(n: int, base: int) -> string {
    if n == 0 {
        return "0";
    }

    let is_negative = n < 0;
    let offset = 0;

    if is_negative {
        n *= -1;
        offset = 1;
    }

    let length = n.log(base);
    let str = string.__new(length + offset);
    let i = 0;

    while n > 0 {
        str.__set_char(offset + length - i - 1, get_char(n % base));
        n /= base;
        i += 1;
    }

    if is_negative {
        str.__set_char(0, '-');
    }

    return str;
}

fn log_int(n: int) {{
    (call $log_int)
}}