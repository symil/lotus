export type(void) system {
    alloc(block_size: int) -> ptr {
        return mem_alloc(block_size);
    }

    free(pointer: ptr) {
        mem_free(pointer);
    }

    retain<T>(value: T) {
        value.__retain();
    }

    collect_garbage() {
        mem_trigger_garbage_collection();
    }

    log<T>(value: T) {
        let str = value.to_string();

        log_string(str);
    }

    get_debug_string<T>(value: T) -> string {
        return value.to_debug_string(Set<ptr>.new());
    }

    dbg<T>(value: T) {
        log_string(@get_debug_string(value));
    }

    log_empty() {{
        (call $log_empty)
    }}

    serialize<T>(value: T) -> int[] {
        let buffer = Buffer {};

        value.__serialize(buffer);

        return buffer.consume();
    }

    deserialize<T>(array: int[]) -> T? {
        let buffer = Buffer.from_array(array);
        let value = T.__deserialize(buffer);

        if buffer.read_overflow {
            return none;
        } else {
            return value;
        }
    }

    int<T>(value: T) {
        log_int(value as int);
    }

    type<T>(value: T) {
        log_string(T.type_name());
    }
}

fn log_string(string) {{
    (call $log_string)
}}

fn log_int(int) {{
    (call $log_int)
}}