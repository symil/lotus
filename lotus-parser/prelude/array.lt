export type(i32) Array<T> {
    type Item = T;

    static __create(length: int) -> This {
        let capacity = length.next_power_of_4();
        let header = @alloc(4);
        let body = @alloc(capacity);

        header[0] = body as int;
        header[1] = length;
        header[2] = capacity;

        return header as This;
    }

    static with_capacity(capacity: int) -> This {
        capacity = capacity.next_power_of_4();
        let header = @alloc(4);
        let body = @alloc(capacity);

        header[0] = body as int;
        header[1] = 0;
        header[2] = capacity;

        return header as This;
    }

    static default() -> This {
        return This.__create(0);
    }

    static __none() -> This {{
        (i32.const 0)
    }}

    __is_none() -> bool {{
        (i32.eqz)
    }}

    __hash() -> int {
        return (this as int).__hash();
    }

    get_iterable_len() -> int {
        return this.len();
    }

    get_iterable_ptr() -> Pointer<T> {
        return this.body();
    }

    add(other: This) -> This {
        return this.concat(other);
    }

    eq(other: This) -> bool {{
        i32.eq
    }}

    ne(other: This) -> bool {{
        i32.ne
    }}

    body() -> Pointer<T> {
        return (this as ptr)[0] as Pointer<T>;
    }

    len() -> int {
        return (this as ptr)[1];
    }

    capacity() -> int {
        return (this as ptr)[2];
    }

    get_at(index: int) -> T {
        return this.body()[index];
    }

    set_at(index: int, value: T) {
        this.body().set_at(index, value);
    }

    get(index: int) -> T? {
        if index >= this.len() {
            return none;
        } else {
            return this.get_at(index);
        }
    }

    clear() {
        let header = this as ptr;

        header[1] = 0;
    }

    push(value: T) -> This {
        let header = this as ptr;
        let body = this.body();
        let length = this.len();
        let capacity = this.capacity();

        if length == capacity {
            capacity *= 4;

            let new_body = @alloc(capacity) as Pointer<T>;

            for i in 0..length {
                new_body[i] = body[i];
            }

            body = new_body;
            header[0] = body as int;
            header[2] = capacity;
        }

        body[length] = value;
        header[1] = length + 1;

        return this;
    }

    pop() -> This {
        let header = this as ptr;
        let length = header[1];

        if length > 0 {
            header[1] = length - 1;
        }

        return this;
    }

    concat(other: This) -> This {
        let new_array = This.__create(this.len() + other.len());
        let new_body = new_array.body();

        let offset = 0;

        for item in this {
            new_body[offset] = item;
            offset += 1;
        }

        for item in other {
            new_body[offset] = item;
            offset += 1;
        }

        return new_array;
    }

    join(separator: string) -> string {
        let str = "";
        let length = this.len();

        if length > 0 {
            let last_index = length - 1;
            let i = 0;

            for item in this {
                str += item.to_string();

                if i != last_index {
                    str += separator;
                }

                i += 1;
            }
        }

        return str;
    }

    as_ptr() -> ptr {
        return this as ptr;
    }

    to_string() -> string {
        if this.__is_none() {
            return "none";
        }

        return "[" + #TYPE_SHORT_NAME + " " + (this as int).to_hexa_string() + "]";
    }

    to_debug_string(set: Set<ptr>) -> string {
        if this.__is_none() {
            return "none";
        }

        let length = this.len();

        if length == 0 {
            return "[]";
        } else {
            let strings : string[] = [];
            let has_line_breaks = false;

            for item in this {
                let str = item.to_debug_string(set);

                if str.contains("\n") {
                    has_line_breaks = true;
                }

                strings.push(str);
            }

            if has_line_breaks {
                return "[\n" + strings.join(",\n").indent(2) + "\n]";
            } else {
                return "[ " + strings.join(", ") + " ]";
            }
        }
    }

    __retain() {
        if mem_retain(this.as_ptr()) {
            mem_retain(this.body() as ptr);

            for item in this {
                item.__retain();
            }
        }
    }

    __serialize(buffer: Buffer) {
        if buffer.register(this) {
            buffer.push(this.len());

            for item in this {
                item.__serialize(buffer);
            }
        }
    }
}