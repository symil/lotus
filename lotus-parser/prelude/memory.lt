const MEMORY_CELL_BYTE_SIZE = 4; // 4B
const WASM_PAGE_BYTE_SIZE = 2.pow(16); // 64 KiB
const VIRTUAL_PAGE_BYTE_SIZE = 2.pow(20); // 1 MiB

const WASM_PAGE_SIZE = WASM_PAGE_BYTE_SIZE / MEMORY_CELL_BYTE_SIZE;
const VIRTUAL_PAGE_SIZE = VIRTUAL_PAGE_BYTE_SIZE / MEMORY_CELL_BYTE_SIZE;
const VIRTUAL_PAGE_SIZE_POWER_OF_TWO = VIRTUAL_PAGE_SIZE.log2();

const WASM_PAGE_COUNT_PER_VIRTUAL_PAGE = VIRTUAL_PAGE_BYTE_SIZE / WASM_PAGE_BYTE_SIZE;

const NULL_ZONE_SIZE = 128;

const VIRTUAL_PAGE_METADATA_SIZE = 4;
const POINTER_METADATA_SIZE = 1;
const MAX_VIRTUAL_PAGE_COUNT_PER_BLOCK_SIZE = 64;
const BLOCK_SIZE_COUNT = 8;
const MEMORY_METADATA_ADDR_START = NULL_ZONE_SIZE;
const MEMORY_METADATA_SIZE = MAX_VIRTUAL_PAGE_COUNT_PER_BLOCK_SIZE * BLOCK_SIZE_COUNT;

const HEADER_WASM_PAGE_COUNT = 1;
const HEADER_SIZE = HEADER_WASM_PAGE_COUNT * WASM_PAGE_SIZE;

const MEMORY = (0 as ptr);

pub fn wasm_store<T>(int, T) {{
    <T>.store
}}

pub fn wasm_load<T>(int) -> T {{
    <T>.load
}}

fn wasm_memory_copy(int, int, int) {{
    memory.copy
}}

fn wasm_memory_grow(int) -> int {{
    memory.grow
}}

fn alloc_page() -> ptr {
    return (wasm_memory_grow(WASM_PAGE_COUNT_PER_VIRTUAL_PAGE) * WASM_PAGE_BYTE_SIZE / MEMORY_CELL_BYTE_SIZE) as ptr;
}

sys fn mem_alloc(block_size: int) -> ptr {
    let result = 0 as ptr;
    let block_size_index = block_size.log4() - 1;
    let list_start_addr = MEMORY_METADATA_ADDR_START + block_size_index * MAX_VIRTUAL_PAGE_COUNT_PER_BLOCK_SIZE;
    let list_end_addr = list_start_addr + MAX_VIRTUAL_PAGE_COUNT_PER_BLOCK_SIZE;

    for i in list_start_addr..list_end_addr {
        let page_addr = MEMORY[i];
        let page_ptr = page_addr as ptr;

        if page_addr == 0 {
            page_ptr = alloc_page();
            MEMORY[i] = page_ptr as int;

            let round_block_size = block_size.next_power_of_4();
            let full_block_size = round_block_size + POINTER_METADATA_SIZE;
            let block_count = (VIRTUAL_PAGE_SIZE - VIRTUAL_PAGE_METADATA_SIZE) / (round_block_size + 1 + POINTER_METADATA_SIZE);
            let stack_start_addr = (page_ptr as int) + VIRTUAL_PAGE_METADATA_SIZE;
            let block_list_start_addr = stack_start_addr + block_count;
            let last_block_addr = block_list_start_addr + (block_count * full_block_size) - round_block_size;

            page_ptr[0] = block_count;
            page_ptr[1] = block_list_start_addr;
            page_ptr[2] = full_block_size;
            page_ptr[3] = block_count;

            for j in 0..block_count {
                MEMORY[stack_start_addr + j] = last_block_addr - (j * full_block_size);
            }
        }

        let offset = page_ptr[0];

        if offset != 0 {
            offset -= 1;
            result = page_ptr[offset + VIRTUAL_PAGE_METADATA_SIZE] as ptr;
            result[-1] = 1;
            page_ptr[0] = offset;
            break;
        }
    }

    return result;
}

sys fn mem_free(pointer: ptr) {
    let addr = pointer as int;
    let page_ptr = (((addr - HEADER_SIZE) >> VIRTUAL_PAGE_SIZE_POWER_OF_TWO) << VIRTUAL_PAGE_SIZE_POWER_OF_TWO) + HEADER_SIZE as ptr;
    let avilable_block_count = page_ptr[0];

    pointer[-1] = 0;
    page_ptr[avilable_block_count + VIRTUAL_PAGE_METADATA_SIZE] = addr;
    page_ptr[0] = avilable_block_count + 1;
}

sys fn mem_trigger_garbage_collection() {
    for i in 0..BLOCK_SIZE_COUNT {
        for j in 0..MAX_VIRTUAL_PAGE_COUNT_PER_BLOCK_SIZE {
            let page_addr = MEMORY[MEMORY_METADATA_ADDR_START + i * MAX_VIRTUAL_PAGE_COUNT_PER_BLOCK_SIZE + j];

            if page_addr == 0 {
                break;
            }

            let page_ptr = page_addr as ptr;
            let block_list_start_addr = page_ptr[1];
            let full_block_size = page_ptr[2];
            let block_count = page_ptr[3];

            for k in 0..block_count {
                let metadata_ptr = block_list_start_addr + (full_block_size * k) as ptr;
                let metadata_value = metadata_ptr[0];

                if metadata_value == 1 {
                    mem_free(metadata_ptr.add(1));
                } else if metadata_value == 2 {
                    metadata_ptr[0] = 1;
                }
            }
        }
    }
}

sys fn mem_retain(addr: ptr) -> bool {
    let success = false;

    if addr[-1] == 1 {
        addr[-1] = 2;
        success = true;
    }

    return success;
}

pub fn mem_copy(dest: ptr, src: ptr, count: int) {
    let dest_arg = (dest as int) * 4;
    let src_arg = (src as int) * 4;
    let count_arg = count * 4;

    wasm_memory_copy(dest_arg, src_arg, count_arg);
}