export class Buffer {
    buffer: ptr,
    size: int,
    capacity: int,
    read_index: int,
    read_overflow: bool,
    set: Set<ptr>,
    map: Map<int, ptr>

    static from_array(array: int[]) -> Buffer {
        return Buffer {
            buffer: array.body(),
            size: array.len(),
            capacity: array.capacity()
        };
    }

    save_addr<T>(value: T) -> bool {
        this.push(value as int);

        if this.set.add(value as ptr) {
            return true;
        } else {
            return false;
        }
    }

    retrieve<T>(key: int) -> T? {
        return (this.map.get(key) as T);
    }

    register<T>(key: int, value: T) {
        this.map.set(key, value as ptr);
    }

    push(value: int) {
        if this.size == this.capacity {
            let new_capacity = (this.capacity + 1).next_power_of_4();
            let new_buffer = @alloc(new_capacity);

            if !this.buffer.is_null() {
                this.buffer.copy_to(new_buffer, this.size);
            }

            this.capacity = new_capacity;
            this.buffer = new_buffer;
        }

        this.buffer[this.size] = value;
        this.size += 1;
    }

    read() -> int? {
        if this.read_index >= this.size {
            this.read_overflow = true;

            return none;
        } else {
            let value = this.buffer[this.read_index];

            this.read_index += 1;

            return value;
        }
    }

    consume() -> int[] {
        return int[]::from_raw_parts(this.buffer, this.size, this.capacity);
    }
}