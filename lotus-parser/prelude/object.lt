export const TYPE_ID_TO_ANCESTOR_IDS = Map<int, Set<int>>.new();
const TYPE_ID_TO_FIELD_COUNT = Map<int, int>.new();

export class Object {
    autogen static __init() {
        // @log("INIT: " + #TYPE_NAME);
        let ancestor_set = Set<int>.new();

        iter_ancestors {
            ancestor_set.add(#ANCESTOR_ID);
        }

        TYPE_ID_TO_FIELD_COUNT.set(#TYPE_ID, #FIELD_COUNT);
        TYPE_ID_TO_ANCESTOR_IDS.set(#TYPE_ID, ancestor_set);
    }

    autogen static __is(object: Object) -> bool {
        let type_id = object.as_ptr()[0];

        return TYPE_ID_TO_ANCESTOR_IDS
            .get(type_id)
            .has(#TYPE_ID);
    }

    autogen dyn get_type_name() -> string {
        return #TYPE_NAME;
    }

    autogen static get_name() -> string {
        return #TYPE_NAME;
    }

    autogen static __create() -> This {
        let data = @alloc(#FIELD_COUNT + 1);

        data[0] = #TYPE_ID;

        return data as This;
    }

    autogen static __default() -> This {
        let obj = This.__create();

        iter_fields {
            obj.#FIELD_NAME = #FIELD_DEFAULT_EXPRESSION;
        }

        return obj;
    }

    autogen static __none() -> This {{
        (i32.const 0)
    }}

    eq(other: This) -> bool {{
        i32.eq
    }}

    ne(other: This) -> bool {{
        i32.ne
    }}

    __is_none() -> bool {{
        (i32.eqz)
    }}

    __hash() -> int {
        return (this as int).__hash();
    }

    as_ptr() -> ptr {
        return this as ptr;
    }

    to_string() -> string {
        if this.__is_none() {
            return "none";
        }

        return this.__to_string_dyn();
    }

    autogen dyn __to_string_dyn() -> string {
        return "[" + #TYPE_SHORT_NAME + " " + (this as int).to_hexa_string() + "]";
    }

    to_debug_string(set: Set<ptr>) -> string {
        if this.__is_none() {
            return "none";
        }

        return this.__to_debug_string_dyn(set);
    }

    autogen dyn __to_debug_string_dyn(set: Set<ptr>) -> string {
        if !set.add(this.as_ptr()) {
            return "<cycle>";
        }

        if #FIELD_COUNT == 0 {
            return #TYPE_SHORT_NAME;
        } else {
            let str = #TYPE_SHORT_NAME + " {\n";

            iter_fields {
                str += (#FIELD_NAME + ": " + this.#FIELD_NAME.to_debug_string(set)).indent(2) + ",\n";
            }

            str += "}";

            return str;
        }
    }

    __retain() {
        if !this.__is_none() {
            this.__retain_dyn();
        }
    }

    autogen dyn __retain_dyn() {
        if mem_retain(this.as_ptr()) {
            iter_fields {
                this.#FIELD_NAME.__retain();
            }
        }
    }

    __serialize(buffer: Buffer) {
        if this.__is_none() {
            buffer.push(0);
        } else {
            this.__serialize_dyn(buffer);
        }
    }

    autogen dyn __serialize_dyn(buffer: Buffer) {
        if buffer.save_addr(this) {
            buffer.push(#TYPE_ID);

            iter_fields {
                this.#FIELD_NAME.__serialize(buffer);
            }
        }
    }

    static __deserialize(buffer: Buffer) -> This? {
        let addr = buffer.read();

        if !addr || addr == 0 {
            return none; // no way to differenciate between "none because no more buffer" and "none because got 0"
        }

        let obj : Object = buffer.retrieve(addr);

        if obj {
            return obj;
        }

        let obj_type_id = buffer.read();

        if !obj_type_id {
            return none;
        }

        let obj_size = TYPE_ID_TO_FIELD_COUNT.get(obj_type_id);

        if !obj_size {
            return none;
        }
        
        let obj_ptr = @alloc(1 + obj_size);
        obj_ptr[0] = obj_type_id;

        obj = obj_ptr as Object;

        buffer.register(addr, obj);

        obj.__deserialize_dyn(buffer);

        return obj;
    }

    autogen dyn __deserialize_dyn(buffer: Buffer) {
        iter_fields {
            this.#FIELD_NAME = #FIELD_TYPE.__deserialize(buffer) as #FIELD_TYPE;
        }
    }
}