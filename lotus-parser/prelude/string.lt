export type(i32) string {
    type Item = char;

    static __new(length: int) -> string {
        let result = @alloc(length + 1);

        result[0] = length;

        return (result as string);
    }

    static __default() -> string {
        return "";
    }

    static __none() -> string {{
        (i32.const 0)
    }}

    __is_none() -> bool {{
        (i32.eqz)
    }}

    __hash() -> int {
        let hash = 0;

        for c in this {
            let char_hash = c.__hash();

            hash += char_hash;
        }

        return hash & 0x3fffffff;
    }

    __set_char(index: int, c: char) -> string {
        (this as ptr)[index + 1] = (c as int);

        return this;
    }

    get_at(index: int) -> char {
        return (this as ptr)[index + 1] as char;
    }

    get_iterable_len() -> int {
        return this.len();
    }

    get_iterable_ptr() -> Pointer<char> {
        return ((this as int) + 1) as Pointer<char>;
    }

    add(other: string) -> string {
        let left = this as ptr;
        let right = other as ptr;
        let left_length = left[0];
        let right_length = right[0];
        let new_length = left_length + right_length;
        let new_string = @alloc(new_length + 1);
        let offset = 1;

        new_string[0] = new_length;

        for i in 0..left_length {
            new_string[offset] = left[i + 1];
            offset += 1;
        }

        for i in 0..right_length {
            new_string[offset] = right[i + 1];
            offset += 1;
        }

        return new_string as string;
    }

    eq(other: string) -> bool {
        let left = this as ptr;
        let right = other as ptr;
        let left_length = left[0];
        let right_length = right[0];

        if left_length != right_length {
            return false;
        }

        for i in 1..(left_length + 1) {
            if left[i] != right[i] {
                return false;
            }
        }

        return true;
    }

    ne(other: string) -> bool {
        return !this.eq(other);
    }

    len() -> int {
        return (this as ptr)[0];
    }

    static __chosen() -> string {
        return "lotus";
    }

    to_string() -> string {
        return this;
    }

    to_debug_string() -> string {
        let result = string.__new(this.len() + 2);

        result.__set_char(0, '"');
        result.__set_char(this.len() + 1, '"');

        mem_copy((result as ptr).add(2), (this as ptr).add(1), this.len());

        return result;
    }

    pad_start(c: char, target_length: int) -> string {
        if this.len() >= target_length {
            return this;
        } else {
            let result = string.__new(target_length);
            let start = target_length - this.len();

            for i in 0..start {
                result.__set_char(i, c);
            }

            mem_copy((result as ptr).add(start + 1), (this as ptr).add(1), this.len());

            return result;
        }
    }

    find(str: string, index: int) -> int? {
        let max_len = this.len() - str.len() + 1;

        for i in index..max_len {
            if this.starts_with(str, i) {
                return i;
            }
        }

        return none;
    }

    starts_with(str: string, index: int) -> bool {
        if index + str.len() > this.len() {
            return false;
        } else {
            for i in 0..str.len() {
                if this[index + i] != str[i] {
                    return false;
                }
            }

            return true;
        }
    }
}