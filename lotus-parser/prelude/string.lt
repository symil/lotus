export type(i32) string {
    type Item = char;

    static __chosen() -> string {
        return "lotus";
    }

    static __new(length: int) -> string {
        let result = @alloc(length + 2);

        result[0] = length;
        result[1] = 0;

        return (result as string);
    }

    static __default() -> string {
        return "";
    }

    static __none() -> string {{
        (i32.const 0)
    }}

    __is_none() -> bool {{
        (i32.eqz)
    }}

    _header() -> ptr {
        return this as ptr;
    }

    _content() -> Pointer<char> {
        return (this as Pointer<char>).add(2);
    }

    __hash() -> int {
        let header = this._header();
        let hash = header[1];

        if hash == 0 {
            hash = 1;

            for c in this {
                hash += c.__hash();
            }

            hash &= 0x3fffffff;

            header[1] = hash;
        }

        return hash;
    }

    __set_char(index: int, c: char) -> string {
        this._content()[index] = c;

        return this;
    }

    get_at(index: int) -> char {
        return this._content()[index];
    }

    get_iterable_len() -> int {
        return this.len();
    }

    get_iterable_ptr() -> Pointer<char> {
        return this._content();
    }

    add(other: string) -> string {
        let new_string = string.__new(this.len() + other.len());
        let new_content =  new_string._content();

        this._content().copy_to(new_content, this.len());
        other._content().copy_to(new_content.add(this.len()), other.len());

        return new_string;
    }

    eq(other: string) -> bool {
        let hash_1 = this.__hash();
        let hash_2 = other.__hash();

        return hash_1 == hash_2;
    }

    ne(other: string) -> bool {
        return !this.eq(other);
    }

    len() -> int {
        return (this as ptr)[0];
    }

    to_string() -> string {
        return this;
    }

    to_debug_string(set: Set<ptr>) -> string {
        let result = string.__new(this.len() + 2);

        result.__set_char(0, '"');
        result.__set_char(this.len() + 1, '"');

        this._content().copy_to(result._content().add(1), this.len());

        return result;
    }

    is_empty() -> bool {
        return this.len() == 0;
    }

    pad_start(c: char, target_length: int) -> string {
        if this.len() >= target_length {
            return this;
        } else {
            let result = string.__new(target_length);
            let start = target_length - this.len();

            for i in 0..start {
                result.__set_char(i, c);
            }

            this._content().copy_to(result._content().add(start), this.len());

            return result;
        }
    }

    find(str: string, index: int) -> int? {
        let max_len = this.len() - str.len() + 1;

        for i in index..max_len {
            if this.starts_with(str, i) {
                return i;
            }
        }

        return none;
    }

    contains(str: string) -> bool {
        return this.find(str, 0).is_some();
    }

    starts_with(str: string, index: int) -> bool {
        if index + str.len() > this.len() {
            return false;
        } else {
            for i in 0..str.len() {
                if this[index + i] != str[i] {
                    return false;
                }
            }

            return true;
        }
    }

    substring(start: int?, end: int?) -> string {
        let length = this.len();
        let start_index = 0;
        let end_index = length;

        if (start) {
            start_index = start?;
        }

        if (end) {
            end_index = end?;
        }

        if start_index < 0 {
            start_index = length + start_index;
        }

        if end_index < 0 {
            end_index = length + end_index;
        }

        start_index = start_index.min(length);
        end_index = end_index.min(length);

        if end_index <= start_index {
            return "";
        }

        let result_length = end_index - start_index;
        let result = string.__new(result_length);

        this._content().add(start_index).copy_to(result._content(), result_length);

        return result;
    }

    split(separator: string) -> string[] {
        if this.len() == 0 {
            return [];
        }

        let result : string[] = [];
        let separator_length = separator.len();

        if separator_length == 0 {
            for c in this {
                result.push(c.to_string());
            }
        } else {
            let start = 0;
            let index = this.find(separator, 0);

            while index {
                result.push(this.substring(start, index));
                start = index + separator_length;
                index = this.find(separator, start);
            }

            result.push(this.substring(start, none));
        }

        return result;
    }

    indent(tab_length: int) -> string {
        let lines = this.split("\n");
        let tab = "".pad_start(' ', tab_length);

        for i in 0..lines.len() {
            lines[i] = tab + lines[i];
        }

        return lines.join("\n");
    }

    __retain() {
        mem_retain(this as ptr);
    }
}