const SERVER : Server = none;

pub class Server {
    _buffer: Buffer = Buffer::with_capacity(BIG_BUFFER_SIZE),
    _world: #WORLD_TYPE = none,
    _websocket_server_id: int,
    _user_to_websocket_id: Map<#USER_TYPE, int>,
    _websocket_id_to_user: Map<int, #USER_TYPE>,
    _websocket_id_counter: Counter,

    _start() {
        self._websocket_server_id = wasm_create_websocket_server(WEBSOCKET_PORT);
        self._world = #WORLD_TYPE;

        @emit(OnWorldInit { server: self, world: self._world }, [self._world]);
    }

    _update() {
        self._process_network_events();
        self._update_world();
        self._update_users();
    }

    _update_world() {
        @emit(OnWorldUpdate { server: self, world: self._world }, [self._world]);
    }

    _process_network_events() {
        self._buffer.clear();
        self._buffer.size = wasm_poll_network_events(self._buffer.data, self._buffer.capacity);

        while !self._buffer.is_finished() {
            let event = decode_network_event_from_buffer(self._buffer);

            match event.kind {
                NetworkEventKind::ConnectionOpen => {
                    let user = #USER_TYPE::__default();

                    self._websocket_id_to_user.set(event.websocket_id, user);
                    self._user_to_websocket_id.set(user, event.websocket_id);

                    @emit(OnUserConnect { server: self, user }, [self._world]);
                },
                NetworkEventKind::ConnectionClosed => {
                    let user = self._websocket_id_to_user.get(event.websocket_id);

                    @emit(OnUserDisconnect { server: self, user }, [self._world]);

                    self._websocket_id_to_user.delete(event.websocket_id);
                    self._user_to_websocket_id.delete(user);
                },
                NetworkEventKind::Message => {
                    let user = self._websocket_id_to_user.get(event.websocket_id);
                    let request : Object = @deserialize(event.payload);

                    if request {
                        @emit(OnUserRequest { server: self, user, request }, [self._world]);
                    }
                }
            }
        }
    }

    _update_users() {
        for entry in self._websocket_id_to_user {
            let websocket_id = entry.key;
            let user = entry.value;

            if user {
                self._buffer.clear();
                self._buffer.context = user;

                #USER_TYPE::__serialize(self._buffer, user);
                wasm_send_message(websocket_id, self._buffer.data, self._buffer.size);
            }
        }
    }

    store<T>(path: string, content: T) {
        self._buffer.clear();
        T::__serialize(self._buffer, content);
        wasm_write_file(path, self._buffer.data, self._buffer.size);
    }

    load<T>(path: string) -> T {
        self._buffer.clear();
        self._buffer.size = wasm_read_file(path, self._buffer.data, self._buffer.capacity);
        self._buffer.read();

        let value = T::__deserialize(self._buffer);

        match self._buffer.has_read_overflow() {
            true => none,
            false => value
        }
    }

    dyn __allows_network_serialization(user: #USER_TYPE) -> bool {
        false
    }
}

sys fn start_server() {
    set_pointer_version_seed(wasm_get_current_time());
    SERVER = Server;
    SERVER._start();
}

sys fn update_server() {
    SERVER._update();
    // @log(`memory used: ${get_memory_usage() / 1024} KB`);
    @retain(SERVER);
    @trigger_garbage_collection();
}