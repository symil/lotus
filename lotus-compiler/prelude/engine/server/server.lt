const SERVER : Server = none;

pub class Server {
    _buffer: Buffer = Buffer::with_capacity(BIG_BUFFER_SIZE),
    _world: #WORLD_TYPE = none,
    _websocket_server_id: int = none,
    _user_to_metadata: Map<#USER_TYPE, UserMetadata> = Map<#USER_TYPE, UserMetadata>::new(),
    _websocket_id_to_user: Map<int, #USER_TYPE> = Map<int, #USER_TYPE>::new(),
    _websocket_id_counter: Counter = Counter,
    _request_to_request_id: Map<Object, int> = Map<Object, int>::new(),

    static get() -> Self {
        SERVER
    }

    _start() {
        self._websocket_server_id = wasm_create_websocket_server(WEBSOCKET_PORT);
        self._world = #WORLD_TYPE::__default();

        @emit(OnWorldInit { server: self, world: self._world }, [self._world]);
    }

    _update() {
        self._process_network_events();
        self._update_world();
        self._update_users();
    }

    _update_world() {
        @emit(OnWorldUpdate { server: self, world: self._world }, [self._world]);
    }

    _process_network_events() {
        self._buffer.reset();
        self._buffer.size = wasm_poll_network_events(self._buffer.data, self._buffer.capacity);

        let events_to_emit : Event[] = [];

        while !self._buffer.is_finished() {
            let websocket_id = self._buffer.read();
            let event_kind = NetworkEventKind::__from_int(self._buffer.read());

            match event_kind {
                NetworkEventKind::ConnectionOpen => {
                    let user = #USER_TYPE::__default();
                    let metadata = UserMetadata {
                        websocket_id,
                    };

                    self._websocket_id_to_user.set(websocket_id, user);
                    self._user_to_metadata.set(user, metadata);

                    events_to_emit.push(OnUserConnect { server: self, world: self._world, user });
                },
                NetworkEventKind::ConnectionClosed => {
                    let user = self._websocket_id_to_user.get(websocket_id);

                    self._websocket_id_to_user.delete(websocket_id);
                    self._user_to_metadata.delete(user);

                    events_to_emit.push(OnUserDisconnect { server: self, world: self._world, user });
                },
                NetworkEventKind::Message => {
                    self._buffer.reset_serialization_utility();

                    let user = self._websocket_id_to_user.get(websocket_id);
                    let payload_size = self._buffer.read();
                    let request_id = self._buffer.read();
                    let request : Object = @deserialize(self._buffer);

                    if request {
                        self._request_to_request_id.set(request, request_id);
                        events_to_emit.push(OnUserRequest { server: self, world: self._world, user, request });
                    }
                }
            }
        }

        for event in events_to_emit {
            @emit(event, [self._world]);

            if event is OnUserRequest(on_user_request) {
                let request_id = self._request_to_request_id.delete(on_user_request.request);
                let metadata = self._user_to_metadata.get(on_user_request.user);
                let success = on_user_request.success;

                if request_id && metadata {
                    metadata.processed_requests.push(RequestResult {
                        request_id,
                        success,
                    });
                }
            }
        }
    }

    _update_users() {
        for entry in self._user_to_metadata {
            let user = entry.key;
            let metadata = entry.value;

            if user {
                if !metadata.processed_requests.is_empty() {
                    self._buffer.reset();
                    self._buffer.write(metadata.processed_requests.len());

                    for request_result in metadata.processed_requests {
                        self._buffer.write(request_result.request_id);
                        self._buffer.write(request_result.success.to_int());
                    }

                    metadata.processed_requests.clear();

                    wasm_send_message(metadata.websocket_id, self._buffer.data, self._buffer.size);
                }

                self._buffer.reset();
                self._buffer.write(0);
                self._buffer.context = user;

                @serialize(user, self._buffer);
                wasm_send_message(metadata.websocket_id, self._buffer.data, self._buffer.size);

                // self._buffer.read_index = 1;
                // let deserialized : #USER_TYPE = @deserialize(self._buffer);
                // if deserialized {
                //     @dbg(deserialized);
                // }
            }
        }
    }

    store<T>(path: string, content: T) {
        self._buffer.reset();
        @serialize(content, self._buffer);
        wasm_write_file(path, self._buffer.data, self._buffer.size);
    }

    load<T>(path: string) -> T {
        self._buffer.reset();
        self._buffer.size = wasm_read_file(path, self._buffer.data, self._buffer.capacity);
        self._buffer.read();

        @deserialize(self._buffer)
    }

    dyn __allows_network_serialization(user: #USER_TYPE) -> bool {
        false
    }
}

sys fn start_server() {
    set_pointer_version_seed(wasm_get_current_time());
    SERVER = Server;
    SERVER._start();
}

sys fn update_server() {
    SERVER._update();
    // @log(`memory used: ${get_memory_usage() / 1024} KB`);
    @retain(SERVER);
    @trigger_garbage_collection();
}