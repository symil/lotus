pub class Layout {
    parent_view: View,
    transform: Transform2D,
    target: Rect,
    last: Rect = none,
    outer_margin: float = 0,
    inner_margin: float = 0,
    dx: float = 0,
    dy: float = 1,
    dynamic: bool = false,
    fixed_views: View[] = [],
    dynamic_views: View[] = [],

    static new(parent_view: View) -> Self {
        let target = parent_view._rect.clone();

        Self { parent_view, target }
    }

    resey() -> Self {
        self._flush();
        self.target = self.parent_view._rect.clone();
        self.towards_bottom();
        self
    }

    dynamic() -> Self {
        self.dynamic = true;
        self
    }

    fixed() -> Self {
        self.dynamic = false;
        self
    }

    scale(ratio: float) -> Self {
        self.target = self.target.scale(ratio);
        self
    }

    scale_width(ratio: float) -> Self {
        self.target = self.target.scale_width(ratio);
        self
    }

    scale_height(ratio: float) -> Self {
        self.target = self.target.scale_height(ratio);
        self
    }

    pad_to_match_aspect_ratio(aspect_ratio: float) -> Self {
        self.target = self.target.pad_to_match_aspect_ratio(aspect_ratio);
        self
    }

    strip_to_match_aspect_ratio(aspect_ratio: float) -> Self {
        self.target = self.target.strip_to_match_aspect_ratio(aspect_ratio);
        self
    }

    outer_margin(value: float) -> Self {
        self.outer_margin = value;
        self
    }

    inner_margin(value: float) -> Self {
        self.inner_margin = value;
        self
    }

    margin(value: float) -> Self {
        self.outer_margin = value;
        self.inner_margin = value;
        self
    }

    move_to(x: float, y: float) -> Self {
        self._flush();
        self.last = none;
        self.target.x = self.parent_view._rect.width * x;
        self.target.y = self.parent_view._rect.height * y;
        self
    }

    set_width(width: float) -> Self {
        self.target.width = self.parent_view._rect.width * width;
        self
    }

    set_height(height: float) -> Self {
        self.target.height = self.parent_view._rect.height * height;
        self
    }

    resize_from_width(width: float, aspect_ratio: float) -> Self {
        self.target.width = self.parent_view._rect.width * width;
        self.target.height = self.target.width / aspect_ratio;
        self
    }

    resize_from_height(height: float, aspect_ratio: float) -> Self {
        self.target.height = self.parent_view._rect.height * height;
        self.target.width = self.target.height * aspect_ratio;
        self
    }

    transform(transform: Transform2D) -> Self {
        self.transform.multiply(transform);
        self
    }

    push(view: View) -> Self {
        let (dx, dy) = self._snap_target_against_last_item();

        self.target.x += dx;
        self.target.y += dy;

        if self.dynamic && self.dynamic_views.len() > 0 {
            for view in self.dynamic_views {
                view._rect.x -= dx / 2f;
                view._rect.y -= dy / 2f;
            }

            self.target.x -= dx / 2f;
            self.target.y -= dy / 2f;
        }

        let (dx, dy) = self._snap_target_against_edges();

        if self.dynamic {
            let (dx2, dy2) = self._snap_first_against_edges();

            dx += dx2;
            dy += dy2;

            for view in self.dynamic_views {
                view._rect.x += dx;
                view._rect.y += dy;
            }
        }

        self.target.x += dx;
        self.target.y += dy;
        self.last = self.target.clone();

        view._rect = self.target.clone();

        self.dynamic_views.push(view);
        self.parent_view._children.push(view);

        self
    }

    push_list(views: View[]) -> Self {
        for view in views {
            self.push(view);
        }

        self
    }

    _snap_target_against_last_item() -> (float, float) {
        if !self.last {
            return (0, 0);
        }

        let dx = self.last.width / 2f + self.inner_margin + self.target.width / 2f;
        let dy = self.last.height / 2f + self.inner_margin + self.target.height / 2f;

        let mx = dx / self.dx.abs();
        let my = dy / self.dy.abs();
        let m = mx.min(my);

        (self.dx * m, self.dy * m)
    }

    _snap_against_edges(rect: Rect) -> (float, float) {
        let parent_rect = self.parent_view._rect;
        let min_x = parent_rect.x1() + self.outer_margin;
        let max_x = parent_rect.x2() - self.outer_margin;
        let min_y = parent_rect.y1() + self.outer_margin;
        let max_y = parent_rect.y2() - self.outer_margin;
        let dx = 0f.clamp(min_x - rect.x1(), max_x - rect.x2());
        let dy = 0f.clamp(min_y - rect.y1(), max_y - rect.y2());

        (dx, dy)
    }

    _snap_target_against_edges() -> (float, float) {
        self._snap_against_edges(self.target)
    }

    _snap_first_against_edges() -> (float, float) {
        if !self.dynamic_views.first() {
            return (0, 0);
        }

        self._snap_against_edges(self.dynamic_views[0]._rect)
    }

    towards(dx: float, dy: float) -> Self {
        self._flush();
        self.dx = dx;
        self.dy = dy;
        self
    }

    _flush() {
        self.fixed_views.extend(self.dynamic_views);
        self.dynamic_views.clear();
    }

    release() -> Self {
        self._flush();
        self
    }

    towards_top() -> Self       { self.towards(0, -1) }
    towards_bottom() -> Self    { self.towards(0,  1) }
    towards_left() -> Self      { self.towards(-1, 0) }
    towards_right() -> Self     { self.towards(1,  0) }

    move_top_left() -> Self     { self.move_to(0  , 0  ) }
    move_top() -> Self          { self.move_to(0.5, 0  ) }
    move_top_right() -> Self    { self.move_to(1  , 0  ) }
    move_left() -> Self         { self.move_to(0  , 0.5) }
    move_center() -> Self       { self.move_to(0.5, 0.5) }
    move_right() -> Self        { self.move_to(1  , 0.5) }
    move_bottom_left() -> Self  { self.move_to(0  , 1  ) }
    move_bottom() -> Self       { self.move_to(0.5, 1  ) }
    move_bottom_right() -> Self { self.move_to(1  , 1  ) }
}