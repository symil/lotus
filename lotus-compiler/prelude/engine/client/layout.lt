pub class Layout {
    parent_view: View,
    transform: Transform2D,
    target: Rect,
    last: Rect = none,
    outer_margin: float = 0,
    inner_margin: float = 0,
    dx: float = 0,
    dy: float = 1,
    dynamic: bool = false,
    fixed_views: View[] = [],
    dynamic_views: View[] = [],

    static new(parent_view: View) -> Self {
        let target = parent_view.rect.clone();

        Self { parent_view, target }
    }

    dynamic() -> Self {
        self.dynamic = true;
        self
    }

    fixed() -> Self {
        self.dynamic = false;
        self
    }

    scale(ratio: float) -> Self {
        self.target = self.target.scale(ratio);
        self
    }

    scale_x(ratio: float) -> Self {
        self.target.width *= ratio;
        self
    }

    scale_y(ratio: float) -> Self {
        self.target.height *= ratio;
        self
    }

    pad_to_match_aspect_ratio(aspect_ratio: float) -> Self {
        self.target = self.target.pad_to_match_aspect_ratio(aspect_ratio);
        self
    }

    strip_to_match_aspect_ratio(aspect_ratio: float) -> Self {
        self.target = self.target.strip_to_match_aspect_ratio(aspect_ratio);
        self
    }

    outer_margin(value: float) -> Self {
        self.outer_margin = value;
        self
    }

    inner_margin(value: float) -> Self {
        self.inner_margin = value;
        self
    }

    margin(value: float) -> Self {
        self.outer_margin = value;
        self.inner_margin = value;
        self
    }

    move_to(x: float, y: float) -> Self {
        self._flush();
        self.last = none;
        self.target.x = self.parent_view.rect.width * x;
        self.target.y = self.parent_view.rect.height * y;
        self
    }

    resize_from_width(width: float, aspect_ratio: float) -> Self {
        self.target.width = self.parent_view.rect.width * width;
        self.target.height = self.target.width / aspect_ratio;
        self
    }

    resize_from_height(height: float, aspect_ratio: float) -> Self {
        self.target.height = self.parent_view.rect.height * height;
        self.target.width = self.target.height * aspect_ratio;
        self
    }

    transform(transform: Transform2D) -> Self {
        self.transform.multiply(transform);
        self
    }

    push(view: View) -> Self {
        let (dx, dy) = self._snap_target_against_last_item();

        self.target.x += dx;
        self.target.y += dy;

        if self.dynamic && self.dynamic_views.len() > 0 {
            for view in self.dynamic_views {
                view.rect.x -= dx / 2f;
                view.rect.y -= dy / 2f;
            }

            self.target.x -= dx / 2f;
            self.target.y -= dy / 2f;
        }

        let (dx, dy) = self._snap_target_against_edges();

        if self.dynamic {
            let (dx2, dy2) = self._snap_first_against_edges();

            dx += dx2;
            dy += dy2;

            for view in self.dynamic_views {
                view.rect.x += dx;
                view.rect.y += dy;
            }
        }

        self.target.x += dx;
        self.target.y += dy;
        self.last = self.target.clone();

        view.rect = self.target.clone();

        self.dynamic_views.push(view);
        self.parent_view.children.push(view);

        self
    }

    _snap_target_against_last_item() -> (float, float) {
        if !self.last {
            return (0, 0);
        }

        let dx = self.last.width / 2f + self.inner_margin + self.target.width / 2f;
        let dy = self.last.height / 2f + self.inner_margin + self.target.height / 2f;

        let mx = dx / self.dx.abs();
        let my = dy / self.dy.abs();
        let m = mx.min(my);

        (self.dx * m, self.dy * m)
    }

    _snap_against_edges(rect: Rect) -> (float, float) {
        let dx = 0f;
        let dy = 0f;

        dx = dx.max(self.outer_margin - rect.x1());
        dx = dx.min(self.parent_view.rect.width - self.outer_margin - rect.x2());

        dy = dy.max(self.outer_margin - rect.y1());
        dy = dy.min(self.parent_view.rect.height - self.outer_margin - rect.y2());

        (dx, dy)
    }

    _snap_target_against_edges() -> (float, float) {
        self._snap_against_edges(self.target)
    }

    _snap_first_against_edges() -> (float, float) {
        if !self.dynamic_views.first() {
            return (0, 0);
        }

        self._snap_against_edges(self.dynamic_views[0].rect)
    }

    towards(dx: float, dy: float) -> Self {
        self._flush();
        self.dx = dx;
        self.dy = dy;
        self
    }

    _flush() {
        self.fixed_views.extend(self.dynamic_views);
        self.dynamic_views.clear();
    }

    release() -> Self {
        self._flush();
        self
    }

    towards_top() -> Self    { self.towards(0, -1) }
    towards_bottom() -> Self { self.towards(0,  1) }
    towards_left() -> Self   { self.towards(-1, 0) }
    towards_right() -> Self  { self.towards(1,  0) }

    move_top_left() -> Self      { self.move_to(0  , 0  ) }
    move_top() -> Self           { self.move_to(0.5, 0  ) }
    move_top_right() -> Self     { self.move_to(1  , 0  ) }
    move_left() -> Self          { self.move_to(0  , 0.5) }
    move_center() -> Self        { self.move_to(0.5, 0.5) }
    move_right() -> Self         { self.move_to(1  , 0.5) }
    move_bottom_left() -> Self   { self.move_to(0  , 1  ) }
    move_bottom() -> Self        { self.move_to(0.5, 1  ) }
    move_bottom_right() -> Self  { self.move_to(1  , 1  ) }
}