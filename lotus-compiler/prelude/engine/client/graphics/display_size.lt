enum DisplaySizeKind {
    Real,
    Virtual,
    ScaledFromContainerWidth,
    ScaledFromContainerHeight,
    ScaledFromContainerMin
}

export class DisplaySize {
    kind: DisplaySizeKind,
    value: float,

    static new(kind: DisplaySizeKind, value: float) -> Self {
        Self { kind, value }
    }

    static real(value: float) -> Self { Self::new(DisplaySizeKind::Real, value) }
    static virtual(value: float) -> Self { Self::new(DisplaySizeKind::Virtual, value) }
    static scaled_from_width(value: float) -> Self { Self::new(DisplaySizeKind::ScaledFromContainerWidth, value) }
    static scaled_from_height(value: float) -> Self { Self::new(DisplaySizeKind::ScaledFromContainerHeight, value) }
    static scaled_from_min(value: float) -> Self { Self::new(DisplaySizeKind::ScaledFromContainerMin, value) }

    scale<F : Number>(ratio: F) -> Self {
        Self {
            kind: self.kind,
            value: self.value * ratio.to_float()
        }
    }

    resolve(virtual_width: float, virtual_height: float, virtual_to_real_ratio: float) -> float {
        if self.__is_none() {
            return 0;
        }

        match self.kind {
            DisplaySizeKind::Real => self.value,
            DisplaySizeKind::Virtual => self.value * virtual_to_real_ratio,
            DisplaySizeKind::ScaledFromContainerWidth => self.value * virtual_width * virtual_to_real_ratio,
            DisplaySizeKind::ScaledFromContainerHeight => self.value * virtual_height * virtual_to_real_ratio,
            DisplaySizeKind::ScaledFromContainerMin => self.value * virtual_width.min(virtual_height) * virtual_to_real_ratio,
        }
    }

    resolve_from_rect(rect: Rect) -> float {
        self.resolve(rect.width, rect.height, 1)
    }
}