const CLIENT : Client = none;

const VIRTUAL_WIDTH = 1600f;
const VIRTUAL_HEIGHT = 900f;

export class Client {
    _buffer: SimpleBuffer,
    _websocket_id: int,
    _layout: Layout,
    _network_events: NetworkEvent[],
    _window_events: WindowEvent[],

    user: #USER_TYPE?,
    local_data: #LOCAL_DATA_TYPE,
    hover_stack: ViewState[],
    all_views: ViewState[],
    real_width: float,
    real_height: float,
    virtual_width: float,
    virtual_height: float,
    virtual_to_real_ratio: float,
    cursor_x: float,
    cursor_y: float,

    static new() -> Self {
        Self {
            _buffer: SimpleBuffer::new(BIG_BUFFER_SIZE),
            virtual_width: VIRTUAL_WIDTH,
            virtual_height: VIRTUAL_HEIGHT
        }
    }

    _start() {
        @log("CLIENT START");

        wasm_init_window(VIRTUAL_WIDTH / VIRTUAL_HEIGHT);
        self._websocket_id = wasm_create_websocket(`ws://localhost:${WEBSOCKET_PORT}`);
    }

    _update() {
        self._collect_network_events();
        self._collect_window_events();
        self._process_network_events();
        self._create_views();
        self._process_window_events();
    }

    _collect_network_events() {
        let written_count = wasm_poll_network_events(self._buffer.pointer, self._buffer.size);

        self._network_events.clear();
        self._buffer.reset_index();

        while self._buffer.index < written_count {
            self._network_events.push(decode_network_event_from_buffer(self._buffer));
        }
    }

    _collect_window_events() {
        let written_count = wasm_poll_window_events(self._buffer.pointer, self._buffer.size);

        self._window_events.clear();
        self._buffer.reset_index();

        while self._buffer.index < written_count {
            let window_event = decode_window_event_from_buffer(self._buffer, self);

            self._window_events.push(window_event);

            if window_event is MouseEvent(mouse_event) {
                self.cursor_x = mouse_event.x;
                self.cursor_y = mouse_event.y;
            }
        }
    }

    _process_network_events() {
        let last_event = self._network_events.last();

        if last_event && last_event.type == NetworkEventType::Message {
            self.user = @deserialize(last_event.payload);
        }
    }

    _create_views() {
        self.hover_stack.clear();
        self.all_views.clear();

        let root_view = #WINDOW_TYPE;
        let root_rect = Rect::from_size(self.virtual_width, self.virtual_height);
        let root_transform = Transform2D::identity();

        self._render_view(root_view, root_rect, root_transform);
        self._compute_hover_stack();
    }

    _render_view(view: Object, rect: Rect, transform: Transform2D) {
        let render_event = Render {
            client: self,
            layout: self._layout.reset(rect, transform)
        };

        let view_state = ViewState { view, transform };

        self.all_views.push(view_state);
        render_event.emit([view]);

        for item in self._layout.consume() {
            match item.object {
                Graphics(graphics) => {
                    if !view_state.hitbox {
                        view_state.hitbox = graphics.get_hitbox(item.rect, item.transform);
                    }

                    view_state.graphics.push(graphics);
                },
                Object(view) => {
                    self._render_view(view, item.rect, item.transform);
                }
            }
        }
    }

    _compute_hover_stack() {
        for wrapper in self.all_views {
            if wrapper.hitbox && wrapper.hitbox.contains(self.cursor_x, self.cursor_y) {
                self.hover_stack.push(wrapper);
            }
        }

        self.hover_stack.reverse().sort((w1, w2) => w2.hitbox.z.compare(w1.hitbox.z));
    }

    _process_window_events() {
        let written_count = wasm_poll_window_events(self._buffer.pointer, self._buffer.size);

        self._buffer.reset_index();

        while self._buffer.index < written_count {
            let window_event = decode_window_event_from_buffer(self._buffer, self);
        }

        self.real_width = wasm_get_window_width();
        self.real_height = wasm_get_window_height();
        self.virtual_to_real_ratio = self.real_width / self.virtual_width;

        let primitive = DrawPrimitive {
            x: 500,
            y: 300,
            width: 200,
            height: 100,
            background_color: ORANGE
        };

        self._buffer.reset_index();
        self._buffer.write(Cursor::Pointer);
        primitive.write_to_buffer(self._buffer);

        wasm_draw_frame(self._buffer.pointer, self._buffer.index);
    }

    send<T>(value: T) {
        let buffer = @serialize(value);

        wasm_send_message(self._websocket_id, buffer.body(), buffer.len());
    }
}

sys fn start_client() {
    CLIENT = Client::new();
    CLIENT._start();
}

sys fn update_client() {
    CLIENT._update();
    // @log(`memory used: ${get_memory_usage() / 1024} KB`);
    @retain(CLIENT);
    @trigger_garbage_collection();
}