const CLIENT : Client = none;

const VIRTUAL_WIDTH = 1600f;
const VIRTUAL_HEIGHT = 900f;

export class Client {
    _buffer: SimpleBuffer,
    _websocket_id: int,
    _layout: Layout,

    user: #USER_TYPE?,
    local_data: #LOCAL_DATA_TYPE,
    hover_stack: View[],
    views: View[],
    real_width: float,
    real_height: float,
    virtual_width: float,
    virtual_height: float,
    virtual_to_real_ratio: float,
    cursor_x: float,
    cursor_y: float,

    static new() -> Self {
        Self {
            buffer: SimpleBuffer::new(BIG_BUFFER_SIZE),
            virtual_width: VIRTUAL_WIDTH,
            virtual_height: VIRTUAL_HEIGHT
        }
    }

    _start() {
        @log("CLIENT START");

        wasm_init_window(VIRTUAL_WIDTH / VIRTUAL_HEIGHT);
        self._websocket_id = wasm_create_websocket(`ws://localhost:${WEBSOCKET_PORT}`);
    }

    _update() {
        self._process_network_events();
        self._process_window_events();
    }

    _create_views() {
        self.hover_stack.clear();
        self.all_views.clear();

        let root_view = #WINDOW_TYPE;
        let root_rect = Rect::from_size(self.virtual_width, self.virtual_height);
        let root_transform = Transform2D::identity();

        self._render_view(root_view, root_rect, root_transform);
    }

    _render_view(view: View, rect: Rect, transform: Transform2D) {
        let render_event = Render {
            client: self,
            layout: self._layout.reset(rect, transform)
        };

        render_event.emit([view]);

        for item in self._layout.consume() {
            
        }

        let graphics = view.graphics.first();

        if graphics && graphics.detectable {
            let hitbox = self.graphics_to_hitbox(graphics, view.transform);

            // view._hitbox = hitbox;
            // view._hitbox_z = graphics.z;
        }
    }

    _process_window_events() {
        let written_count = wasm_poll_window_events(self._buffer.pointer, self._buffer.size);

        self._buffer.reset_index();

        while self._buffer.index < written_count {
            let window_event = decode_window_event_from_buffer(self._buffer, self);
        }

        self.real_width = wasm_get_window_width();
        self.real_height = wasm_get_window_height();
        self.virtual_to_real_ratio = self.real_width / self.virtual_width;

        let primitive = DrawPrimitive {
            x: 500,
            y: 300,
            width: 200,
            height: 100,
            background_color: ORANGE
        };

        self._buffer.reset_index();
        self._buffer.write(Cursor::Pointer);
        primitive.write_to_buffer(self._buffer);

        wasm_draw_frame(self._buffer.pointer, self._buffer.index);
    }

    _process_network_events() {
        let written_count = wasm_poll_network_events(self._buffer.pointer, self._buffer.size);
        let network_events : NetworkEvent[] = [];

        self._buffer.reset_index();

        while self._buffer.index < written_count {
            network_events.push(decode_network_event_from_buffer(self._buffer));
        }

        let last_event = network_events.last();

        if last_event && last_event.type == NetworkEventType::Message {
            self.user = @deserialize(last_event.payload);
        }
    }

    send<T>(value: T) {
        let buffer = @serialize(value);

        wasm_send_message(self._websocket_id, buffer.body(), buffer.len());
    }
}

sys fn start_client() {
    CLIENT = Client::new();
    CLIENT._start();
}

sys fn update_client() {
    CLIENT._update();
    // @log(`memory used: ${get_memory_usage() / 1024} KB`);
    @retain(CLIENT);
    @trigger_garbage_collection();
}