const CLIENT : Client = none;

const VIRTUAL_WIDTH = 1600f;
const VIRTUAL_HEIGHT = 900f;

export class Client {
    _buffer: Buffer = Buffer::with_capacity(BIG_BUFFER_SIZE),
    _websocket_id: int,
    _layout: Layout,
    _draw_primitives: DrawPrimitive[],
    _network_events: NetworkEvent[],
    _window_events: WindowEvent[],

    _focused_index: int?,

    user: #USER_TYPE?,
    local_data: DataStore,
    hovered_view: View?,
    focus_chain: View[],
    focused_view: View?,
    all_views: View[],
    real_width: float,
    real_height: float,
    virtual_width: float = VIRTUAL_WIDTH,
    virtual_height: float = VIRTUAL_HEIGHT,
    virtual_to_real_ratio: float,
    cursor_x: float,
    cursor_y: float,

    _start() {
        wasm_init_window(VIRTUAL_WIDTH / VIRTUAL_HEIGHT);
        self._websocket_id = wasm_create_websocket(`ws://localhost:${WEBSOCKET_PORT}`);
    }

    _update() {
        self._collect_network_events();
        self._collect_window_events();
        self._process_network_events();
        self._create_views();
        self._draw_frame();
        self._process_window_events();
    }

    _collect_network_events() {
        self._network_events.clear();
        self._buffer.clear();
        self._buffer.size = wasm_poll_network_events(self._buffer.data, self._buffer.capacity);

        while !self._buffer.is_finished() {
            self._network_events.push(decode_network_event_from_buffer(self._buffer));
        }
    }

    _collect_window_events() {
        self.real_width = wasm_get_window_width();
        self.real_height = wasm_get_window_height();
        self.virtual_to_real_ratio = self.real_width / self.virtual_width;

        self._window_events.clear();
        self._buffer.clear();
        self._buffer.size = wasm_poll_window_events(self._buffer.data, self._buffer.capacity);

        while !self._buffer.is_finished() {
            let window_event = decode_window_event_from_buffer(self._buffer, self);
            let push = true;

            if window_event is OnMouseEvent(mouse_event) {
                mouse_event.x /= self.virtual_to_real_ratio;
                mouse_event.y /= self.virtual_to_real_ratio;

                self.cursor_x = mouse_event.x;
                self.cursor_y = mouse_event.y;

                if mouse_event.action == MouseAction::Move {
                    push = false;
                }
            }

            if push {
                self._window_events.push(window_event);
            }
        }
    }

    _process_network_events() {
        let last_event = self._network_events.last();

        if last_event && last_event.kind == NetworkEventKind::Message {
            self.user = @deserialize(last_event.payload);
        }
    }

    _create_views() {
        let root_view = #WINDOW_TYPE {
            _rect: Rect::from_size(self.virtual_width, self.virtual_height)
        };

        self.all_views.clear();
        self.focus_chain.clear();
        // TODO: clear focused & hovered view?
        self._render_view(root_view);
        self.hovered_view = self._detect_view_at(self.cursor_x, self.cursor_y);
        self._define_interactions();
        self.focused_view = self.focus_chain.get(self._focused_index);

        if self.focused_view {
            self.focused_view._focused = true;
        }
    }

    _render_view(view: View) {
        let event = OnRender {
            client: self,
        };

        view._client = self;
        event.emit([view]);
        self.all_views.push(view);

        for child in view._children {
            self._render_view(child);
        }
    }

    _detect_view_at(x: float, y: float) -> View? {
        let current : View = none;

        for view in self.all_views {
            if view._graphics.detectable && view._rect.contains(x, y) {
                if !current || view._rect.z >= current._rect.z {
                    current = view;
                }
            }
        }

        current
    }

    _define_interactions() {
        let event = OnDefineMouseInteractions;
        let views = self.all_views.clone().reverse();

        event.emit(views);
    }

    _draw_frame() {
        self._draw_primitives.clear();

        let cursor = Cursor::Default;

        for view in self.all_views {
            if self.hovered_view == view {
                view._graphics.set(view._hovered_graphics);
            }

            if self.focused_view == view {
                view._graphics.set(view._focused_graphics);
            }
            
            if self.hovered_view == view {
                cursor = view._graphics.cursor;
            }

            let draw_primitive = view._graphics.__to_draw_primitive(view._rect, self.virtual_to_real_ratio);

            self._draw_primitives.push(draw_primitive);

            // if view.graphics.text {
            //     @dbg(draw_primitive);
            // }
        }

        self._buffer.clear();
        self._buffer.write_unchecked(cursor);

        for primitive in self._draw_primitives {
            primitive.write_to_buffer(self._buffer);
        }

        wasm_draw_frame(self._buffer.data, self._buffer.size);
    }

    _process_window_events() {
        let views = self.all_views.clone().reverse();

        for event in self._window_events {
            match event {
                OnMouseEvent(e) => {
                    let view = self._detect_view_at(e.x, e.y);

                    if view {
                        let callback_list = match e.action {
                            MouseAction::Down => view._on_down_callbacks,
                            MouseAction::Click => view._on_click_callbacks,
                            MouseAction::Up => view._on_up_callbacks,
                            MouseAction::Drag => view._on_drag_callbacks
                        };

                        for callback in callback_list {
                            callback();
                        }
                    }
                },
                OnKeyboardEvent(event) => {
                    event.emit(views);
                },
                OnWheelEvent(event) => {
                    event.emit(views);
                }
            }
        }
    }

    request<T>(value: T) {
        self._buffer.clear();
        T::__serialize(self._buffer, value);

        wasm_send_message(self._websocket_id, self._buffer.data, self._buffer.size);
    }

    add_to_focus_chain(view: View) {
        self.focus_chain.push(view);
    }

    focus(view: View?) {
        if self.focused_view == view {
            return;
        }

        if self.focused_view {
            self.focused_view._focused = false;
        }

        if (view) {
            view._focused = true;
            self._focused_index = self.focus_chain.index_of(view);

            OnFocus { target: view }.emit([view]);
        } else {
            self._focused_index = none;
        }

        self.focused_view = view;
    }

    _focus_next_or_prev(d: int) {
        let focused_item_count = self.focus_chain.len();

        if self._focused_index {
            self.focus(self.focus_chain[(focused_item_count + self._focused_index + d) % focused_item_count]);
        } else {
            self.focus(self.focus_chain.first());
        }
    }

    focus_next() {
        self._focus_next_or_prev(1);
    }

    focus_prev() {
        self._focus_next_or_prev(-1);
    }

    set_local_storage_item<T>(key: string, data: T) {
        self._buffer.clear();
        T::__serialize_with_schema(self._buffer, data);

        wasm_set_local_storage_item(key, self._buffer.data, self._buffer.size);
    }

    get_local_storage_item<T>(key: string) -> T? {
        self._buffer.clear();
        self._buffer.size = wasm_get_local_storage_item(key, self._buffer.data, self._buffer.capacity);

        let value = T::__deserialize_with_schema(self._buffer);

        match self._buffer.has_read_overflow() {
            true => none,
            false => value
        }
    }

    clear_local_storage() {
        wasm_clear_local_storage();
    }

    set_window_title(title: string) {
        wasm_set_window_title(title);
    }

    dyn __allows_network_serialization(user: #USER_TYPE) -> bool {
        false
    }
}

sys fn start_client() {
    CLIENT = Client;
    CLIENT._start();
}

sys fn update_client() {
    CLIENT._update();
    // @log(`memory used: ${get_memory_usage() / 1024} KB`);
    @retain(CLIENT);
    @trigger_garbage_collection();
}