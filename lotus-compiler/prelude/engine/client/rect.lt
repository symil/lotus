export class Rect {
    // Center of the rectangle
    x: float,
    y: float,
    // Dimensions of the rectangle
    width: float,
    height: float,

    static new(x: float, y: float, width: float, height: float) -> Self {
        Self { x, y, width, height }
    }

    static from_top_left(x1: float, y1: float, width: float, height: float) -> Self {
        let x = x1 + width / 2.0;
        let y = y1 + height / 2.0;

        Self { x, y, width, height }
    }

    static from_size(width: float, height: float) -> Self {
        let x = width / 2.0;
        let y = height / 2.0;

        Self { x, y, width, height }
    }

    static from_corners(x1: float, y1: float, x2: float, y2: float) -> Self {
        let x = (x1 + x2) / 2.0;
        let y = (y1 + y2) / 2.0;
        let width = x2 - x1;
        let height = y2 - y1;

        Self { x, y, width, height }
    }

    x1() -> float {
        self.x - self.width / 2f
    }
    
    y1() -> float {
        self.y - self.height / 2f
    }

    x2() -> float {
        self.x + self.width / 2f
    }

    y2() -> float {
        self.y + self.height / 2f
    }

    clone() -> Self {
        Self::new(self.x, self.y, self.width, self.height)
    }

    round() -> Self {
        Self::from_corners(self.x1().round(), self.y1().round(), self.x2().round(), self.y2().round())
    }

    contains(x: float, y: float) -> bool {
        x > self.x1() && x < self.x2() && y > self.y1() && y < self.y2()
    }

    with_center(x: float, y: float) -> Self {
        Self::new(x, y, self.width, self.height)
    }

    with_size(width: float, height: float) -> Self {
        Self::new(self.x, self.y, width, height)
    }

    translate(tx: float, ty: float) -> Self {
        Self::new(self.x + tx, self.y + ty, self.width, self.height)
    }

    scale(ratio: float) -> Self {
        Self::new(self.x, self.y, self.width * ratio, self.height * ratio)
    }

    multiply(ratio: float) -> Self {
        Self::new(self.x * ratio, self.y * ratio, self.width * ratio, self.height * ratio)
    }

    pad(width: float, height: float) -> Self {
        Self::new(self.x, self.y, self.width + width, self.height + height)
    }

    strip(width: float, height: float) -> Self {
        Self::new(self.x, self.y, self.width - width, self.height - height)
    }

    pad_to_match_aspect_ratio(aspect_ratio: float?) -> Self {
        if !aspect_ratio {
            return self.clone();
        }

        let width_from_height = self.height * aspect_ratio;
        let height_from_width = self.width / aspect_ratio;
        let width_to_pad = 0f;
        let height_to_pad = 0f;

        if self.width < width_from_height {
            width_to_pad = width_from_height - self.width;
        } else {
            height_to_pad = height_from_width - self.height;
        }

        self.pad(width_to_pad, height_to_pad)
    }

    strip_to_match_aspect_ratio(aspect_ratio: float?) -> Self {
        if !aspect_ratio {
            return self.clone();
        }

        let width_from_height = self.height * aspect_ratio;
        let height_from_width = self.width / aspect_ratio;
        let width_to_strip = 0f;
        let height_to_strip = 0f;

        if self.width > width_from_height {
            width_to_strip = self.width - width_from_height;
        } else {
            height_to_strip = self.height - height_from_width;
        }

        self.strip(width_to_strip, height_to_strip)
    }

    split_horizontally(left_width: float) -> (Self, Self) {
        let right_width = self.width - left_width;

        (
            Self::from_top_left(self.x1(), self.y1(), left_width, self.height),
            Self::from_top_left(self.x2() - right_width, self.y1(), right_width, self.height),
        )
    }

    split_vertically(top_height: float) -> (Self, Self) {
        let bottom_height = self.width - top_height;

        (
            Self::from_top_left(self.x1(), self.y1(), self.width, top_height),
            Self::from_top_left(self.x1(), self.y2() - bottom_height, self.width, bottom_height),
        )
    }

    symmetry(cx: float, cy: float) -> Self {
        let x = 2f * cx - self.x;
        let y = 2f * cy - self.y;

        Self::new(x, y, self.width, self.height)
    }

    transform(transform: Transform2D) -> Self {
        let (x, y) = transform.apply(self.x, self.y);
        let (width, height) = transform.scale(self.width, self.height);

        Self::new(x, y, width, height)
    }
}