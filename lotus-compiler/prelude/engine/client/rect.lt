export class Rect {
    // Center of the rectangle
    x: float,
    y: float,
    // Dimensions of the rectangle
    width: float,
    height: float,
    // Used to determine which rectangle is on top of the other
    z: float

    static empty() -> Self {
        Self { x:0, y: 0, width: 0, height: 0 }
    }

    static new(x: float, y: float, width: float, height: float) -> Self {
        Self { x, y, width, height }
    }

    static from_top_left(x1: float, y1: float, width: float, height: float) -> Self {
        let x = x1 + width / 2.0;
        let y = y1 + height / 2.0;

        Self { x, y, width, height }
    }

    static from_size(width: float, height: float) -> Self {
        let x = width / 2.0;
        let y = height / 2.0;

        Self { x, y, width, height }
    }

    static from_corners(x1: float, y1: float, x2: float, y2: float) -> Self {
        let x = (x1 + x2) / 2.0;
        let y = (y1 + y2) / 2.0;
        let width = x2 - x1;
        let height = y2 - y1;

        Self { x, y, width, height }
    }

    x1() -> float {
        self.x - self.width / 2f
    }
    
    y1() -> float {
        self.y - self.height / 2f
    }

    x2() -> float {
        self.x + self.width / 2f
    }

    y2() -> float {
        self.y + self.height / 2f
    }

    contains(x: float, y: float) -> bool {
        x > self.x1() && x < self.x2() && y > self.y1() && y < self.y2()
    }

    clone() -> Self {
        Self {
            x: self.x,
            y: self.y,
            z: self.z,
            width: self.width,
            height: self.height,
        }
    }

    set_z(z: float) -> Self {
        self.z = z;
        self
    }

    round() -> Self {
        let x1 = self.x1().round();
        let x2 = self.x2().round();
        let y1 = self.y1().round();
        let y2 = self.y2().round();

        self.x = (x1 + x2) / 2f;
        self.y = (y1 + y2) / 2f;
        self.width = x2 - x1;
        self.height = y2 - y1;

        self
    }

    set_center(x: float, y: float) -> Self {
        self.x = x;
        self.y = y;
        self
    }

    set_size(width: float, height: float) -> Self {
        self.width = width;
        self.height= height;
        self
    }

    translate(tx: float, ty: float) -> Self {
        self.x += tx;
        self.y += ty;
        self
    }

    scale(ratio: float) -> Self {
        self.width *= ratio;
        self.height *= ratio;
        self
    }

    multiply(ratio: float) -> Self {
        self.x *= ratio;
        self.y *= ratio;
        self.width *= ratio;
        self.height *= ratio;
        self
    }

    pad(width: float, height: float) -> Self {
        self.width += width;
        self.height += height;
        self
    }

    strip(width: float, height: float) -> Self {
        self.width -= width;
        self.height -= height;
        self
    }

    pad_to_match_aspect_ratio(aspect_ratio: float?) -> Self {
        if !aspect_ratio {
            return self;
        }

        let width_from_height = self.height * aspect_ratio;
        let height_from_width = self.width / aspect_ratio;
        let width_to_pad = 0f;
        let height_to_pad = 0f;

        if self.width < width_from_height {
            width_to_pad = width_from_height - self.width;
        } else {
            height_to_pad = height_from_width - self.height;
        }

        self.pad(width_to_pad, height_to_pad)
    }

    strip_to_match_aspect_ratio(aspect_ratio: float?) -> Self {
        if !aspect_ratio {
            return self;
        }

        let width_from_height = self.height * aspect_ratio;
        let height_from_width = self.width / aspect_ratio;
        let width_to_strip = 0f;
        let height_to_strip = 0f;

        if self.width > width_from_height {
            width_to_strip = self.width - width_from_height;
        } else {
            height_to_strip = self.height - height_from_width;
        }

        self.strip(width_to_strip, height_to_strip)
    }

    mirror(cx: float, cy: float) -> Self {
        self.x = 2f * cx - self.x;
        self.y = 2f * cy - self.y;
        self
    }

    transform(transform: Transform2D) -> Self {
        let (x, y) = transform.apply(self.x, self.y);
        let (width, height) = transform.scale(self.width, self.height);

        Self::new(x, y, width, height)
    }

    split_horizontally(left_width: float) -> (Self, Self) {
        let right_width = self.width - left_width;

        (
            Self::from_top_left(self.x1(), self.y1(), left_width, self.height),
            Self::from_top_left(self.x2() - right_width, self.y1(), right_width, self.height),
        )
    }

    split_vertically(top_height: float) -> (Self, Self) {
        let bottom_height = self.width - top_height;

        (
            Self::from_top_left(self.x1(), self.y1(), self.width, top_height),
            Self::from_top_left(self.x1(), self.y2() - bottom_height, self.width, bottom_height),
        )
    }
}