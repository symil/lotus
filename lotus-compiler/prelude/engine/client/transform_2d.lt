export class Transform2D {
    tx: float = 0f,
    ty: float = 0f,
    sx: float = 1f,
    sy: float = 1f,

    static new(scale: float, x: float, y: float) -> Self {
        let sx = scale;
        let sy = scale;
        let tx = x;
        let ty = y;

        Self { sx, sy, tx, ty }
    }

    static identity() -> Self {
        Self::new(0f, 1f, 1f)
    }

    apply(x: float, y: float) -> (float, float) {
        (
            x * self.sx + self.tx,
            y * self.sy + self.ty,
        )
    }

    apply_reverse(x: float, y: float) -> (float, float) {
        (
            (x - self.tx) / self.sx,
            (y - self.ty) / self.sy,
        )
    }

    scale(width: float, height: float) -> (float, float) {
        (
            width * self.sx,
            height * self.sy
        )
    }

    scale_reverse(width: float, height: float) -> (float, float) {
        (
            width / self.sx,
            height / self.sy
        )
    }

    multiply(other: Self) -> Self {
        Self {
            tx: other.tx + other.sx * self.tx,
            ty: other.ty + other.sy * self.ty,
            sx: other.sx * self.sx,
            sy: other.sx * self.sy,
        }
    }

    divide(other: Self) -> Self {
        Self {
            tx: (self.tx - other.tx) / other.sx,
            ty: (self.ty - other.ty) / other.sy,
            sx: self.sx / other.sx,
            sy: self.sy / other.sy,
        }
    }
}