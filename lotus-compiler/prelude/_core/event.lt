type EventCallback = fn(Object, Event, EventOutput);
type EventCallbackMap = Map<int, Map<int, EventCallback[]>>;

export const EVENT_HOOKS = EventCallbackMap::new();
export const BEFORE_EVENT_CALLBACKS = EventCallbackMap::new();
export const AFTER_EVENT_CALLBACKS = EventCallbackMap::new();

export class EventOutput {
    intercepted: bool,
    yielded: Object[],
}

sys fn insert_event_callback(event_map: EventCallbackMap, event_type_id: int, target_type_id: int, callback: EventCallback) {
    let callback_map = event_map.get_or_insert_with(event_type_id, () => Map<int, EventCallback[]>::new());
    let callback_list = callback_map.get_or_insert_with(target_type_id, () => []);

    callback_list.push(callback);
}

pub fn emit_event(event: Object, targets: Object[]) {
    let output = EventOutput;
    let event_type_id = event.get_type_id();

    for event_map in [EVENT_HOOKS, BEFORE_EVENT_CALLBACKS, AFTER_EVENT_CALLBACKS] {
        if event_map == AFTER_EVENT_CALLBACKS {
            event.trigger();
        }

        let callback_map = event_map.get(event_type_id);

        if !callback_map {
            continue;
        }

        for target in targets {
            let callback_list = callback_map.get(target.get_type_id());

            if !callback_list {
                continue;
            }

            for callback in callback_list {
                output.yielded.clear();

                callback(target, event, output);

                for object in output.yielded {
                    event.yield(object);
                }

                if output.intercepted {
                    return;
                }
            }
        }
    }
}