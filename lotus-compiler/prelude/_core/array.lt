export type(i32) Array<T> {
    type Item = T;

    static __create(length: int) -> This {
        let capacity = length.next_power_of_4();
        let header = @alloc(4);
        let body = @alloc(capacity);

        header[0] = body as int;
        header[1] = length;
        header[2] = capacity;

        header as This
    }

    static with_capacity(capacity: int) -> This {
        capacity = capacity.next_power_of_4();
        let header = @alloc(4);
        let body = @alloc(capacity);

        header[0] = body as int;
        header[1] = 0;
        header[2] = capacity;

        header as This
    }

    static from_raw_parts(pointer: Pointer<T>, length: int, capacity: int) -> This {
        let header = @alloc(4);

        header[0] = pointer as int;
        header[1] = length;
        header[2] = capacity;

        header as This
    }

    static default() -> This {
        This::__create(0)
    }

    static type_name() -> string {
        #TYPE_NAME
    }

    static __none() -> This {{
        (i32.const 0)
    }}

    __is_none() -> bool {{
        (i32.eqz)
    }}

    __hash() -> int {
        (this as int).__hash()
    }

    get_iterable_len() -> int {
        this.len()
    }

    get_iterable_ptr() -> Pointer<T> {
        this.body()
    }

    add(other: This) -> This {
        this.concat(other)
    }

    eq(other: This) -> bool {{
        i32.eq
    }}

    ne(other: This) -> bool {{
        i32.ne
    }}

    body() -> Pointer<T> {
        (this as ptr)[0] as Pointer<T>
    }

    len() -> int {
        (this as ptr)[1]
    }

    capacity() -> int {
        (this as ptr)[2]
    }

    get_at(index: int) -> T {
        let length = this.len();

        if index < 0 {
            index = length + index;
        }

        match index < 0 || index >= length {
            true => none,
            false => this.body()[index]
        }
    }

    set_at(index: int, value: T) {
        this.body().set_at(index, value);
    }

    as_ptr() -> ptr {
        this as ptr
    }

    to_string() -> string {
        if this.__is_none() {
            return "none";
        }

        "[" + #TYPE_SHORT_NAME + " " + (this as int).to_hexa_string() + "]"
    }

    to_debug_string(set: Set<ptr>) -> string {
        if this.__is_none() {
            return "none";
        }

        let length = this.len();

        if length == 0 {
            return "[]";
        }

        let strings : string[] = [];
        let has_line_breaks = false;

        for item in this {
            let str = item.to_debug_string(set);

            if str.contains("\n") {
                has_line_breaks = true;
            }

            strings.push(str);
        }

        match has_line_breaks {
            true => "[\n" + strings.join(",\n").indent(2) + "\n]",
            false => "[ " + strings.join(", ") + " ]"
        }
    }

    static __retain(value: This) {
        if mem_retain(value.as_ptr()) {
            mem_retain(value.body() as ptr);

            for item in value {
                Item::__retain(item);
            }
        }
    }

    __serialize(buffer: Buffer) {
        if buffer.save_addr(this) {
            buffer.push(this.len());

            for item in this {
                item.__serialize(buffer);
            }
        }
    }

    static __deserialize(buffer: Buffer) -> This? {
        let addr = buffer.read();

        if !addr || addr == 0 {
            return none;
        }

        let array : This = buffer.retrieve(addr);

        if (array) {
            return array;
        }

        let length = buffer.read();
        array = This::with_capacity(length);

        buffer.register(addr, array);

        for i in 0..length {
            array.push(T::__deserialize(buffer));
        }

        array
    }

    is_empty() -> bool {
        this.len() == 0
    }

    clone() -> This {
        let result : This = [];

        result.extend(this);

        result
    }

    reverse() -> This {
        let length = this.len();
        let body = this.body();

        for i in 0..(length / 2) {
            let i2 = length - i - 1;
            let tmp = body[i];

            body[i] = body[i2];
            body[i2] = tmp;
        }

        this
    }

    clear() {
        let header = this as ptr;

        header[1] = 0;
    }

    _add_length(additional_length: int) -> int {
        let header = this as ptr;
        let current_length = this.len();
        let new_length = current_length + additional_length;

        if new_length > this.capacity() {
            let body = this.body();
            let new_capacity = this.capacity() * 4;
            let new_body = @alloc(new_capacity) as Pointer<T>;

            for i in 0..current_length {
                new_body[i] = body[i];
            }

            header[0] = new_body as int;
            header[2] = new_capacity;
        }

        header[1] = new_length;

        current_length
    }

    push(value: T) -> This {
        let length = this._add_length(1);

        this.body()[length] = value;

        this
    }

    pop() -> This {
        let header = this as ptr;
        let length = header[1];

        if length > 0 {
            header[1] = length - 1;
        }

        this
    }

    extend(other: This) {
        let length = this._add_length(other.len());
        let body = this.body();

        for (i, item) in other {
            body[length + i] = item;
        }
    }

    extend_at(index: int, other: This) {
        if other.is_empty() {
            return;
        }

        this.insert_none(index, other.len());
        let body = this.body();
        
        for (i, item) in other {
            body[index + i] = item;
        }
    }

    insert_at(index: int, item: Item) {
        this.insert_none(index, 1);
        this[index] = item;
    }

    insert_none(index: int, count: int) {
        let length = this._add_length(count);
        let body = this.body();

        for i in 0..count {
            let i2 = count - i - 1;
            body[index + count + i2] = body[index + i2];
        }

        for i in 0..count {
            body[index + i] = none;
        }
    }

    concat(other: This) -> This {
        let new_array = This::__create(this.len() + other.len());
        let new_body = new_array.body();

        let offset = 0;

        for item in this {
            new_body[offset] = item;
            offset += 1;
        }

        for item in other {
            new_body[offset] = item;
            offset += 1;
        }

        new_array
    }

    join(separator: string) -> string {
        let str = "";
        let length = this.len();

        if length > 0 {
            let last_index = length - 1;
            let i = 0;

            for item in this {
                str += item.to_string();

                if i != last_index {
                    str += separator;
                }

                i += 1;
            }
        }

        str
    }

    filter(callback: fn(T)(bool)) -> T[] {
        let result : T[] = [];

        for item in this {
            if callback(item) {
                result.push(item);
            }
        }

        result
    }

    map<U>(callback: fn(T)(U)) -> U[] {
        let result : U[] = [];

        for item in this {
            result.push(callback(item));
        }

        result
    }

    reduce<U>(init: U, callback: fn(U, T)(U)) -> U {
        let result = init;

        for item in this {
            result = callback(result, item);
        }
        
        result
    }

    sort(compare: fn(T, T)(int)) -> This {
        quick_sort(this.body(), 0, this.len() - 1, compare);

        this
    }
}

fn partition<T>(array: Pointer<T>, start_index: int, end_index: int, compare: fn(T, T)(int)) -> int {
    let pivot = array[end_index];
    let i = start_index - 1;

    for j in start_index..end_index {
        if compare(array[j], pivot) < 0 {
            i += 1;
            array.swap(i, j);
        }
    }

    array.swap(i + 1, end_index);

    i + 1
}

fn quick_sort<T>(array: Pointer<T>, start_index: int, end_index: int, compare: fn(T, T)(int)) {
    if start_index < end_index {
        let mid = partition(array, start_index, end_index, compare);

        quick_sort(array, start_index, mid - 1, compare);
        quick_sort(array, mid + 1, end_index, compare);
    }
}