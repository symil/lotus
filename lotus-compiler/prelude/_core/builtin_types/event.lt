type EventTypeId = int;
type TargetTypeId = int;
type EventCallbackIndex = int;
type EventCallback = fn(Object, Event, EventOutput);
type EventCallbackMap = Map<int, Map<int, EventCallback[]>>;

sys const EVENT_CALLBACKS = Map<EventTypeId, Map<EventCallbackIndex, Map<TargetTypeId, EventCallback[]>>>::new();

export class Event extends Object {
    emit(targets: Object[]) {
        emit_event(self, targets);
    }

    dyn __yield(object: Object) {

    }
}

export class EventOutput {
    intercepted: bool = false,
    yielded: Object[] = [],
}

sys fn insert_event_callback(event_type_id: int, callback_priority: int, target_type_id: int, callback: EventCallback) {
    let callback_indexes = EVENT_CALLBACKS.get_or_insert_with(event_type_id, () => Map<EventCallbackIndex, Map<TargetTypeId, EventCallback[]>>::new());
    let target_callbacks = callback_indexes.get_or_insert_with(callback_priority, () => Map<TargetTypeId, EventCallback[]>::new());
    let callback_list = target_callbacks.get_or_insert_with(target_type_id, () => []);

    callback_list.push(callback);
}

sys fn sort_event_callbacks() {
    for entry in EVENT_CALLBACKS {
        entry.value.sort((a, b) => a - b);
    }
}

pub fn emit_event(event: Event, targets: Object[]) {
    let output = EventOutput;
    let event_type_id = event.__get_type_id();
    let event_map = EVENT_CALLBACKS.get(event_type_id);

    if !event_map {
        return;
    }

    for event_entry in event_map {
        let callback_map = event_entry.value;

        for target in targets {
            check trigger_event_callbacks(callback_map, event, target, output);
        }

        check trigger_event_callbacks(callback_map, event, event, output);
    }
}

pub fn trigger_event_callbacks(callback_map: Map<TargetTypeId, EventCallback[]>, event: Event, target: Object, output: EventOutput) -> bool {
    let callback_list = callback_map.get(target.__get_type_id());

    if !callback_list {
        return true;
    }

    for callback in callback_list {
        callback(target, event, output);

        for object in output.yielded {
            event.__yield(object);
        }

        if output.intercepted {
            return false;
        }
    }

    true
}