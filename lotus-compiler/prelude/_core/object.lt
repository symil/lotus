export const TYPE_ID_TO_ANCESTOR_IDS = Map<int, Set<int>>::new();
const TYPE_ID_TO_FIELD_COUNT = Map<int, int>::new();

export class Object {
    autogen static __init() {
        // @log("INIT: " + #TYPE_NAME);
        let ancestor_set = Set<int>::new();

        iter_ancestors {
            ancestor_set.add(#ANCESTOR_ID);
        }

        TYPE_ID_TO_FIELD_COUNT.set(#TYPE_ID, #FIELD_COUNT);
        TYPE_ID_TO_ANCESTOR_IDS.set(#TYPE_ID, ancestor_set);
    }

    autogen static __is(object: Object) -> bool {
        if object.__is_none() {
            return false;
        }

        let type_id = object.as_ptr()[0];

        TYPE_ID_TO_ANCESTOR_IDS
            .get(type_id)
            .has(#TYPE_ID)
    }

    autogen static get_name() -> string {
        #TYPE_NAME
    }

    autogen static __create() -> This {
        let data = @alloc(#FIELD_COUNT + 1);

        data[0] = #TYPE_ID;

        data as This
    }

    autogen static __default() -> This {
        let obj = This::__create();

        iter_fields {
            obj.#FIELD_NAME = #FIELD_DEFAULT_EXPRESSION;
        }

        obj
    }

    autogen static type_name() -> string {
        #TYPE_NAME
    }

    autogen static __none() -> This {{
        (i32.const 0)
    }}

    eq(other: This) -> bool {{
        i32.eq
    }}

    ne(other: This) -> bool {{
        i32.ne
    }}

    __is_none() -> bool {{
        (i32.eqz)
    }}

    __hash() -> int {
        (this as int).__hash()
    }

    as_ptr() -> ptr {
        this as ptr
    }

    get_type_id() -> int {
        this.as_ptr()[0]
    }

    to_string() -> string {
        match this.__is_none() {
            true => "none",
            false => this.__to_string_dyn()
        }
    }

    autogen dyn __to_string_dyn() -> string {
        "[" + #TYPE_SHORT_NAME + " " + (this as int).to_hexa_string() + "]"
    }

    to_debug_string(set: Set<ptr>) -> string {
        match this.__is_none() {
            true => "none",
            false => this.__to_debug_string_dyn(set)
        }
    }

    autogen dyn __to_debug_string_dyn(set: Set<ptr>) -> string {
        if !set.add(this.as_ptr()) {
            return #TYPE_SHORT_NAME + " { <cycle> }";
        }

        match #FIELD_COUNT == 0 {
            true => #TYPE_SHORT_NAME,
            false => {
                let str = #TYPE_SHORT_NAME + " {\n";

                iter_fields {
                    str += (#FIELD_NAME + ": " + this.#FIELD_NAME.to_debug_string(set)).indent(2) + ",\n";
                }

                str += "}";

                str
            }
        }
    }

    static __retain(value: This) {
        if mem_retain(value.as_ptr()) {
            value.__retain_dyn();
        }
    }

    autogen dyn __retain_dyn() {
        iter_fields {
            #FIELD_TYPE::__retain(this.#FIELD_NAME);
        }
    }

    __serialize(buffer: Buffer) {
        if this.__is_none() {
            buffer.push(0);
        } else {
            this.__serialize_dyn(buffer);
        }
    }

    autogen dyn __serialize_dyn(buffer: Buffer) {
        if buffer.save_addr(this) {
            buffer.push(#TYPE_ID);

            iter_fields {
                this.#FIELD_NAME.__serialize(buffer);
            }
        }
    }

    static __deserialize(buffer: Buffer) -> This? {
        let addr = buffer.read();

        if !addr || addr == 0 {
            return none; // no way to differenciate between "none because no more buffer" and "none because got 0"
        }

        let obj : Object = buffer.retrieve(addr);

        if obj {
            return obj;
        }

        let obj_type_id = buffer.read();

        if !obj_type_id {
            return none;
        }

        let obj_size = TYPE_ID_TO_FIELD_COUNT.get(obj_type_id);

        if !obj_size {
            return none;
        }
        
        let obj_ptr = @alloc(1 + obj_size);
        obj_ptr[0] = obj_type_id;

        obj = obj_ptr as Object;

        buffer.register(addr, obj);

        obj.__deserialize_dyn(buffer);

        obj
    }

    autogen dyn __deserialize_dyn(buffer: Buffer) {
        iter_fields {
            this.#FIELD_NAME = #FIELD_TYPE::__deserialize(buffer) as #FIELD_TYPE;
        }
    }
}