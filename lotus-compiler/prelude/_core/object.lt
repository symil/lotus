const TYPE_CAPACITY = 1024; // TODO: use a macro
const TYPE_ID_TO_FIELD_COUNT = Map<int, int>::with_capacity(TYPE_CAPACITY);
export const TYPE_ID_TO_ANCESTOR_IDS = Map<int, Set<int>>::with_capacity(TYPE_CAPACITY);

export class Object {
    autogen static __init() {
        // @log("INIT: " + #TYPE_NAME);
        let ancestor_set = Set<int>::new();

        iter_ancestors {
            ancestor_set.add(#ANCESTOR_ID);
        }

        TYPE_ID_TO_FIELD_COUNT.set(#TYPE_ID, #FIELD_COUNT);
        TYPE_ID_TO_ANCESTOR_IDS.set(#TYPE_ID, ancestor_set);
    }

    autogen static __is(object: Object) -> bool {
        if object.__is_none() {
            return false;
        }

        let type_id = object.__as_ptr()[0];

        TYPE_ID_TO_ANCESTOR_IDS
            .get(type_id)
            .has(#TYPE_ID)
    }

    autogen static __create() -> Self {
        let data = @alloc(#FIELD_COUNT + 1);

        data[0] = #TYPE_ID;

        data as Self
    }

    autogen static __default() -> Self {
        let obj = Self::__create();

        iter_fields {
            obj.#FIELD_NAME = #FIELD_DEFAULT_EXPRESSION;
        }

        obj
    }

    autogen static __type_name() -> string {
        #TYPE_NAME
    }

    autogen static __none() -> Self {{
        (i32.const 0)
    }}

    __eq(other: Self) -> bool {{
        i32.eq
    }}

    __ne(other: Self) -> bool {{
        i32.ne
    }}

    __is_none() -> bool {{
        (i32.eqz)
    }}

    __hash() -> int {
        (self as int).__hash()
    }

    __as_ptr() -> ptr {
        self as ptr
    }

    __get_type_id() -> int {
        self.__as_ptr()[0]
    }

    to_string() -> string {
        match self.__is_none() {
            true => "none",
            false => self.__to_string_dyn()
        }
    }

    autogen dyn __to_string_dyn() -> string {
        "[" + #TYPE_SHORT_NAME + " " + (self as int).to_hexa_string() + "]"
    }

    __to_debug_string(set: Set<ptr>) -> string {
        match self.__is_none() {
            true => "none",
            false => self.__to_debug_string_dyn(set)
        }
    }

    autogen dyn __to_debug_string_dyn(set: Set<ptr>) -> string {
        if !set.add(self.__as_ptr()) {
            return #TYPE_SHORT_NAME + " { <cycle> }";
        }

        match #FIELD_COUNT == 0 {
            true => #TYPE_SHORT_NAME,
            false => {
                let str = #TYPE_SHORT_NAME + " {\n";

                iter_fields {
                    str += (#FIELD_NAME + ": " + self.#FIELD_NAME.__to_debug_string(set)).indent(2) + ",\n";
                }

                str += "}";

                str
            }
        }
    }

    static __retain(value: Self) {
        if retain_memory(value.__as_ptr()) {
            value.__retain_dyn();
        }
    }

    autogen dyn __retain_dyn() {
        iter_fields {
            #FIELD_TYPE::__retain(self.#FIELD_NAME);
        }
    }

    static __serialize(buffer: Buffer, value: Self) {
        if !value || (buffer.context && !value.__allow_network_serialization(buffer.context as #USER_TYPE)) {
            buffer.write(0);
        } else {
            value.__serialize_dyn(buffer);
        }
    }

    autogen dyn __serialize_dyn(buffer: Buffer) {
        if buffer.save_addr(self) {
            buffer.write(#TYPE_ID);

            iter_fields {
                #FIELD_TYPE::__serialize(buffer, self.#FIELD_NAME);
            }
        }
    }

    static __deserialize(buffer: Buffer) -> Self? {
        let addr = buffer.read();

        if !addr || addr == 0 {
            return none; // no way to differenciate between "none because no more buffer" and "none because got 0"
        }

        let obj : Object = buffer.retrieve(addr);

        if obj {
            return obj;
        }

        let obj_type_id = buffer.read();

        if !obj_type_id {
            return none;
        }

        let obj_size = TYPE_ID_TO_FIELD_COUNT.get(obj_type_id);

        if !obj_size {
            return none;
        }
        
        let obj_ptr = @alloc(1 + obj_size);
        obj_ptr[0] = obj_type_id;

        obj = obj_ptr as Object;

        buffer.register(addr, obj);

        obj.__deserialize_dyn(buffer);

        obj
    }

    autogen dyn __deserialize_dyn(buffer: Buffer) {
        iter_fields {
            self.#FIELD_NAME = #FIELD_TYPE::__deserialize(buffer) as #FIELD_TYPE;
        }
    }

    dyn __allow_network_serialization(user: #USER_TYPE) -> bool {
        true
    }
}