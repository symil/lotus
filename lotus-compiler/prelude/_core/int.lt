export type(i32) int {
    add(int) -> int {{ i32.add }}
    sub(int) -> int {{ i32.sub }}
    mul(int) -> int {{ i32.mul }}
    div(int) -> int {{ i32.div_s }}
    mod(int) -> int {{ i32.rem_s }}
    shl(int) -> int {{ i32.shl }}
    shr(int) -> int {{ i32.shr_u }}
    and(int) -> int {{ i32.and }}
    or(int) -> int {{ i32.or }}
    xor(int) -> int {{ i32.xor }}
    eq(int) -> bool {{ i32.eq }}
    ne(int) -> bool {{ i32.ne }}
    ge(int) -> bool {{ i32.ge_s }}
    gt(int) -> bool {{ i32.gt_s }}
    le(int) -> bool {{ i32.le_s }}
    lt(int) -> bool {{ i32.lt_s }}
    eqz() -> bool {{ i32.eqz }}
    not() -> int {{ (i32.xor (i32.const 0xffffffff)) }}
    plus() -> int {{ }}
    minus() -> int {{ (i32.mul (i32.const -1)) }}

    clz() -> int {{ i32.clz }}
    ctz() -> int {{ i32.ctz }}
    to_int() -> int {{ }}
    as_float() -> float {{ f32.reinterpret_i32 }}
    to_float() -> float {{ f32.convert_i32_s }}
    to_bool() -> bool {{ (i32.eqz i32.eqz) }}
    to_char() -> char {{ }}

    print() {{ (call $__log_int) }}

    static default() -> int {{
        (i32.const 0)
    }}

    static type_name() -> string {
        #TYPE_NAME
    }

    static __none() -> int {{
        (i32.const -2147483648)
    }}

    __is_none() -> bool {{
        (i32.const -2147483648)
        (i32.eq)
    }}

    min(other: int) -> int {
        match self < other {
            true => self,
            false => other
        }
    }

    max(other: int) -> int {
        match self > other {
            true => self,
            false => other
        }
    }

    clamp(min: int, max: int) -> int {
        match self < min {
            true => min,
            false => match self > max {
                true => max,
                false => self
            }
        }
    }

    to_hexa_string() -> string {
        "0x" + int_to_string(self, 16).pad_start('0', 8)
    }

    to_string() -> string {
        match self.__is_none() {
            true => "none",
            false => int_to_string(self, 10)
        }
    }

    to_debug_string(set: Set<ptr>) -> string {
        self.to_string()
    }

    log(base: int) -> int {
        if self < 1 {
            return 1;
        }

        let n = self;
        let result = 0;

        while n > 0 {
            result += 1;
            n /= base;
        }

        result
    }
    
    log2() -> int {
        match self < 2 {
            true => 1,
            false => 32 - (self - 1).clz()
        }
    }

    next_power_of_2() -> int {
        1 << self.log2()
    }

    log4() -> int {
        match self < 4 {
            true => 1,
            false => (33 - (self - 1).clz()) / 2
        }
    }

    next_power_of_4() -> int {
        1 << (self.log4() * 2)
    }

    pow(exponent: int) -> int {
        let result = 1;

        while exponent > 0 {
            result = result * self;
            exponent = exponent - 1;
        }

        result
    }

    // https://github.com/nodejs/node/blob/238104c531219db05e3421521c305404ce0c0cce/deps/v8/src/utils/utils.h#L213
    __hash() -> int {
        let hash = self;

        hash = ~hash + (hash << 15);
        hash = hash ^ (hash >> 12);
        hash = hash + (hash << 2);
        hash = hash ^ (hash >> 4);
        hash = hash * 2057;
        hash = hash ^ (hash >> 16);

        hash & 0x3fffffff
    }

    static __retain(Self) {{

    }}

    __serialize(buffer: Buffer) {
        buffer.write(self);
    }

    static __deserialize(buffer: Buffer) -> int? {
        buffer.read()
    }
}

fn get_char(n: int) -> char {
    match n < 10 {
        true => ('0'.to_int() + n).to_char(),
        false => ('A'.to_int() + (n - 10)).to_char()
    }
}

fn int_to_string(n: int, base: int) -> string {
    if n == 0 {
        return "0";
    }

    let is_negative = n < 0;
    let offset = 0;

    if is_negative {
        n *= -1;
        offset = 1;
    }

    let length = n.log(base);
    let str = string::__create(length + offset);
    let i = 0;

    while n > 0 {
        str.__set_char(offset + length - i - 1, get_char(n % base));
        n /= base;
        i += 1;
    }

    if is_negative {
        str.__set_char(0, '-');
    }

    str
}

fn log_int(n: int) {{
    (call $log_int)
}}