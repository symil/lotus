const START_CAPACITY = 32;

export class Map<K, V> {
    type Item = MapEntry<K, V>;

    hash_table: MapEntry<K, V>?[],
    data_table: MapEntry<K, V>[],
    size: int,

    static default() -> Self {
        Self::new()
    }

    static new() -> Self {
        Self::with_capacity(START_CAPACITY)
    }

    static with_capacity(capacity: int) -> Self {
        let bucket_count = capacity.next_power_of_2() / 2;
        let map = Self {};

        for i in 0..bucket_count {
            map.hash_table.push(none);
        }

        map
    }

    _rehash() {
        let new_map = Self::with_capacity(self.data_table.len() * 2);

        for entry in self.data_table {
            if entry.key {
                new_map.set(entry.key, entry.value);
            }
        }

        self.hash_table = new_map.hash_table;
        self.data_table = new_map.data_table;
        self.size = new_map.size;
    }

    _get_index(key: K) -> int {
        let hash = key.__hash();
        let index = hash % self.hash_table.len();

        index
    }

    _get_entry(key: K) -> Item? {
        let index = self._get_index(key);
        let entry = self.hash_table[index];

        while entry && entry.key != key {
            entry = entry.next;
        }

        entry
    }

    capacity() -> int {
        self.hash_table.len() * 2
    }

    keys() -> K[] {
        let array = Array<K>::__create(self.size);
        let body = array.body();
        let i = 0;

        for entry in self.data_table {
            if entry.key {
                body[i] = entry.key;
                i += 1;
            }
        }

        array
    }

    values() -> V[] {
        let array = Array<V>::__create(self.size);
        let body = array.body();
        let i = 0;

        for entry in self.data_table {
            if entry.key {
                body[i] = entry.value;
                i += 1;
            }
        }

        array
    }

    entries() -> Entry<K, V>[] {
        let array = Array<Entry<K, V>>::__create(self.size);
        let body = array.body();
        let i = 0;

        for entry in self.data_table {
            if entry.key {
                body[i] = Entry<K, V> {
                    key: entry.key,
                    value: entry.value
                };
                i += 1;
            }
        }

        array
    }

    size() -> int {
        self.size
    }

    clear() {
        for i in 0..self.hash_table.len() {
            self.hash_table[i] = none;
        }

        self.data_table.clear();
        self.size = 0;
    }

    get(key: K) -> V? {
        let entry = self._get_entry(key);

        match !!entry {
            true => entry.value,
            false => none
        }
    }

    get_or_insert_with(key: K, f: fn()(V)) -> V {
        let value = self.get(key);

        if !value {
            value = f();
            
            self.set(key, value);
        }

        value
    }

    set(key: K, value: V) -> V? {
        let index = self._get_index(key);
        let entry = self.hash_table[index];
        let last : MapEntry<K, V>? = none;
        let already_present = false;

        while entry && entry.key != key {
            last = entry;
            entry = entry.next;
        }

        if !entry {
            entry = MapEntry<K, V> {
                key: key,
                value: value,
                next: none
            };

            self.data_table.push(entry);
            self.size += 1;

            if last {
                last.next = entry;
            } else {
                self.hash_table[index] = entry;
            }

            if self.data_table.len() > self.hash_table.len() * 2 {
                self._rehash();
            }

            none
        } else {
            let ret = entry.value;

            entry.key = key;
            entry.value = value;

            ret
        }
    }

    delete(key: K) -> V? {
        let entry = self._get_entry(key);

        if entry && entry.key {
            let ret = entry.value;

            entry.key = none;
            entry.value = none;
            self.size -= 1;

            return ret;
        }

        none
    }
}

class MapEntry<K, V> {
    key: K?,
    value: V?,
    next: MapEntry<K, V>?
}

class Entry<K, V> {
    key: K,
    value: V
}