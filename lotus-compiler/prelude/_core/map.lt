const START_CAPACITY = 32;

export class Map<K, V> {
    type Item = MapEntry<K, V>;

    hash_table: MapEntry<K, V>?[],
    data_table: MapEntry<K, V>[],
    size: int,

    static default() -> This {
        This::new()
    }

    static new() -> This {
        This::with_capacity(START_CAPACITY)
    }

    static with_capacity(capacity: int) -> This {
        let bucket_count = capacity.next_power_of_2() / 2;
        let map = This {};

        for i in 0..bucket_count {
            map.hash_table.push(none);
        }

        map
    }

    _rehash() {
        let new_map = This::with_capacity(this.data_table.len() * 2);

        for entry in this.data_table {
            if entry.key {
                new_map.set(entry.key, entry.value);
            }
        }

        this.hash_table = new_map.hash_table;
        this.data_table = new_map.data_table;
        this.size = new_map.size;
    }

    _get_index(key: K) -> int {
        let hash = key.__hash();
        let index = hash % this.hash_table.len();

        index
    }

    _get_entry(key: K) -> Item? {
        let index = this._get_index(key);
        let entry = this.hash_table[index];

        while entry && entry.key != key {
            entry = entry.next;
        }

        entry
    }

    capacity() -> int {
        this.hash_table.len() * 2
    }

    keys() -> K[] {
        let array = Array<K>::__create(this.size);
        let body = array.body();
        let i = 0;

        for entry in this.data_table {
            if entry.key {
                body[i] = entry.key;
                i += 1;
            }
        }

        array
    }

    values() -> V[] {
        let array = Array<V>::__create(this.size);
        let body = array.body();
        let i = 0;

        for entry in this.data_table {
            if entry.key {
                body[i] = entry.value;
                i += 1;
            }
        }

        array
    }

    entries() -> Entry<K, V>[] {
        let array = Array<Entry<K, V>>::__create(this.size);
        let body = array.body();
        let i = 0;

        for entry in this.data_table {
            if entry.key {
                body[i] = Entry<K, V> {
                    key: entry.key,
                    value: entry.value
                };
                i += 1;
            }
        }

        array
    }

    size() -> int {
        this.size
    }

    clear() {
        for i in 0..this.hash_table.len() {
            this.hash_table[i] = none;
        }

        this.data_table.clear();
        this.size = 0;
    }

    get(key: K) -> V? {
        let entry = this._get_entry(key);

        match !!entry {
            true => entry.value,
            false => none
        }
    }

    set(key: K, value: V) -> V? {
        let index = this._get_index(key);
        let entry = this.hash_table[index];
        let last : MapEntry<K, V>? = none;
        let already_present = false;

        while entry && entry.key != key {
            last = entry;
            entry = entry.next;
        }

        if !entry {
            entry = MapEntry<K, V> {
                key: key,
                value: value,
                next: none
            };

            this.data_table.push(entry);
            this.size += 1;

            if last {
                last.next = entry;
            } else {
                this.hash_table[index] = entry;
            }

            if this.data_table.len() > this.hash_table.len() * 2 {
                this._rehash();
            }

            none
        } else {
            let ret = entry.value;

            entry.key = key;
            entry.value = value;

            ret
        }
    }

    delete(key: K) -> V? {
        let entry = this._get_entry(key);

        if entry && entry.key {
            let ret = entry.value;

            entry.key = none;
            entry.value = none;
            this.size -= 1;

            return ret;
        }

        none
    }
}

class MapEntry<K, V> {
    key: K?,
    value: V?,
    next: MapEntry<K, V>?
}

class Entry<K, V> {
    key: K,
    value: V
}