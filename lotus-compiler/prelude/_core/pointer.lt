export type ptr = Pointer<int>;

export type(i32) Pointer<T> {
    type Item = T;

    static default() -> This {{
        (i32.const 0)
    }}

    static type_name() -> string {
        #TYPE_NAME
    }

    static __none() -> This {{
        (i32.const 0)
    }}

    __is_none() -> bool {{
        i32.eqz
    }}

    __hash() -> int {
        (this as int).__hash()
    }

    is_null() -> bool {{
        i32.eqz
    }}

    eq(other: This) -> bool {{
        i32.eq
    }}

    ne(other: This) -> bool {{
        i32.ne
    }}

    add(offset: int) -> This {
        ((this as int) + offset) as This
    }

    addr() -> int {
        this as int
    }

    set_at(index: int, value: T) {
        let byte_index = ((this as int) + index) * 4;

        wasm_store(byte_index, value);
    }

    get_at(index: int) -> T {
        let byte_index = ((this as int) + index) * 4;

        wasm_load(byte_index)
    }

    print() {{
        (call $__log_int)
    }}

    copy_to(target: This, data_size: int) {
        mem_copy(target as ptr, this as ptr, data_size);
    }

    to_string() -> string {
        if this.__is_none() {
            return "none";
        }

        "[Pointer " + (this as int).to_hexa_string() + "]"
    }

    to_debug_string(set: Set<ptr>) -> string {
        if this.__is_none() {
            return "none";
        }

        (this as int).to_hexa_string()
    }

    static __retain(value: This) {
        mem_retain(value as ptr);
    }

    __serialize(buffer: Buffer) {
        buffer.push(this as int);
    }

    static __deserialize(buffer: Buffer) -> This? {
        buffer.read() as This
    }
}

