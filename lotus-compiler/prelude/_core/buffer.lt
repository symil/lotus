export class Buffer {
    data: ptr,
    size: int,
    capacity: int,
    read_index: int,
    set: Set<ptr>,
    map: Map<int, ptr>,
    context: Object?

    static new(capacity: int) -> Buffer {
        let data = @alloc(capacity);

        Self { data, capacity }
    }

    static from_array(array: int[]) -> Buffer {
        Buffer {
            data: array.body(),
            size: array.len(),
            capacity: array.capacity()
        }
    }

    clear() {
        self.size = 0;
        self.read_index = 0;
        self.set.clear();
        self.map.clear();
        self.context = none;
    }

    save_addr<T>(value: T) -> bool {
        self.write(value as int);

        self.set.add(value as ptr)
    }

    retrieve<T>(key: int) -> T? {
        (self.map.get(key) as T)
    }

    register<T>(key: int, value: T) {
        self.map.set(key, value as ptr);
    }

    write(value: int) {
        if self.size == self.capacity {
            let new_capacity = (self.capacity + 1).next_power_of_4();
            let new_buffer = @alloc(new_capacity);

            if !self.data.is_null() {
                self.data.copy_to(new_buffer, self.size);
            }

            self.capacity = new_capacity;
            self.data = new_buffer;
        }

        self.write_unchecked(value)
    }

    write_unchecked<T>(value: T) {
        (self.data as Pointer<T>)[self.size] = value;
        self.size += 1;
    }

    read() -> int? {
        if self.read_index >= self.size {
            self.read_index = self.size + 1;
            none
        } else {
            self.read_unchecked()
        }
    }

    read_unchecked<T>() -> T {
        let result = (self.data as Pointer<T>)[self.read_index];
        self.read_index += 1;
        result
    }

    read_buffer_unchecked() -> int[] {
        let length : int = self.read_unchecked();
        let pointer = @alloc(length);

        self.data.add(self.read_index).copy_to(pointer, length);
        self.read_index += length;

        Array<int>::from_raw_parts(pointer, length, length)
    }

    has_read_overflow() -> bool {
        self.read_index > self.size
    }

    is_finished() -> bool {
        self.read_index >= self.size
    }

    consume() -> int[] {
        Array<int>::from_raw_parts(self.data, self.size, self.capacity)
    }
}