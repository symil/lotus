export class Buffer {
    buffer: ptr,
    size: int,
    capacity: int,
    read_index: int,
    read_overflow: bool,
    set: Set<ptr>,
    map: Map<int, ptr>

    static from_pointer(size: int, pointer: ptr) -> Buffer {
        Buffer {
            buffer: pointer,
            size: size,
            capacity: size
        }
    }

    static from_array(array: int[]) -> Buffer {
        Buffer {
            buffer: array.body(),
            size: array.len(),
            capacity: array.capacity()
        }
    }

    reset() {
        self.read_index = 0;
        self.read_overflow = false;
    }

    save_addr<T>(value: T) -> bool {
        self.push(value as int);

        self.set.add(value as ptr)
    }

    retrieve<T>(key: int) -> T? {
        (self.map.get(key) as T)
    }

    register<T>(key: int, value: T) {
        self.map.set(key, value as ptr);
    }

    push(value: int) {
        if self.size == self.capacity {
            let new_capacity = (self.capacity + 1).next_power_of_4();
            let new_buffer = @alloc(new_capacity);

            if !self.buffer.is_null() {
                self.buffer.copy_to(new_buffer, self.size);
            }

            self.capacity = new_capacity;
            self.buffer = new_buffer;
        }

        self.buffer[self.size] = value;
        self.size += 1;
    }

    read() -> int? {
        if self.read_index >= self.size {
            self.read_overflow = true;

            none
        } else {
            let value = self.buffer[self.read_index];

            self.read_index += 1;

            value
        }
    }

    consume() -> int[] {
        int[]::from_raw_parts(self.buffer, self.size, self.capacity)
    }
}