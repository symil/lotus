const MEMORY_CELL_BYTE_SIZE = 4; // 4B
const WASM_PAGE_BYTE_SIZE = 2.pow(16); // 64 KiB
const VIRTUAL_PAGE_BYTE_SIZE = 2.pow(20); // 1 MiB

const WASM_PAGE_SIZE = WASM_PAGE_BYTE_SIZE / MEMORY_CELL_BYTE_SIZE;
const VIRTUAL_PAGE_SIZE = VIRTUAL_PAGE_BYTE_SIZE / MEMORY_CELL_BYTE_SIZE;
const VIRTUAL_PAGE_SIZE_POWER_OF_TWO = VIRTUAL_PAGE_SIZE.log2();

const WASM_PAGE_COUNT_PER_VIRTUAL_PAGE = VIRTUAL_PAGE_BYTE_SIZE / WASM_PAGE_BYTE_SIZE;

const NULL_ZONE_SIZE = 128;

const VIRTUAL_PAGE_METADATA_SIZE = 4;
const POINTER_METADATA_SIZE = 1;
const MAX_VIRTUAL_PAGE_COUNT_PER_BLOCK_SIZE = 64;
const BLOCK_SIZE_COUNT = 8;
const MAX_BLOCK_SIZE = 4.pow(BLOCK_SIZE_COUNT);
const MEMORY_METADATA_ADDR_START = NULL_ZONE_SIZE;
const MEMORY_METADATA_SIZE = MAX_VIRTUAL_PAGE_COUNT_PER_BLOCK_SIZE * BLOCK_SIZE_COUNT;

let BIG_BLOCK_COUNT = 0; // Actually not a constant
const BIG_BLOCKS_METADATA_START = MEMORY_METADATA_ADDR_START + MEMORY_METADATA_SIZE;

const HEADER_WASM_PAGE_COUNT = 1;
const HEADER_SIZE = HEADER_WASM_PAGE_COUNT * WASM_PAGE_SIZE;

const MEMORY = (0 as ptr);

// Each allocated pointer has a single value (32 bits) of metadata:
// - the 30 most significant bits indicates the number of times the pointer has been allocated (it is incremented each time the pointer is allocated)
// - the 2 least significant bits indicate the state of the pointer

enum PointerState {
    Unallocated, // (= 0) the pointer is unallocated and may be returned by a future call of `alloc_memory`
    Allocated,   // (= 1) the pointer is allocated but will be garbage collected the next time GC is triggered
    Retained,    // (= 2) the pointer has been retained and will not be garbage collected the next time GC is triggered
}

// Triggering the garbage collection changes the state of all pointer from `Allocated` to `Unallocated` and from `Retained` to `Allocated`
// Retaining a pointer changes its state from `Allocated` to `Retained`
// In order for a pointer not to be unallocated by the garbage collector, it is necessary that it is retained before each GC call

let SEED = 0192837465;

// https://en.wikipedia.org/wiki/Linear_congruential_generator
fn get_random_version() -> int {
    SEED = (1103515245 * SEED + 12345).__mod_u(0x7fffffff);

    SEED & 0x3fffffff
}

pub fn init_memory() {
    trigger_garbage_collection();
}

sys fn alloc_memory(block_size: int) -> ptr {
    if block_size >= MAX_BLOCK_SIZE {
        for i in 0..BIG_BLOCK_COUNT {
            let block_ptr = MEMORY[BIG_BLOCKS_METADATA_START + i] as ptr;
            
            if block_ptr[0] >= block_size && get_pointer_state(block_ptr[1]) == PointerState::Unallocated {
                block_ptr[1] = set_pointer_state(block_ptr[1], PointerState::Allocated);

                return block_ptr.add(2);
            }
        }

        let rounded_block_size = ((block_size - 1) / WASM_PAGE_SIZE + 1) * WASM_PAGE_SIZE;
        let block_ptr = (wasm_memory_grow(rounded_block_size / WASM_PAGE_SIZE) * WASM_PAGE_BYTE_SIZE / MEMORY_CELL_BYTE_SIZE) as ptr;

        block_ptr[0] = rounded_block_size;
        block_ptr[1] = set_pointer_state(get_random_version() << 2, PointerState::Allocated);

        MEMORY[BIG_BLOCKS_METADATA_START + BIG_BLOCK_COUNT] = block_ptr as int;
        BIG_BLOCK_COUNT += 1;

        return block_ptr.add(2);
    }

    let result = 0 as ptr;
    let block_size_index = block_size.log4() - 1;
    let list_start_addr = MEMORY_METADATA_ADDR_START + block_size_index * MAX_VIRTUAL_PAGE_COUNT_PER_BLOCK_SIZE;
    let list_end_addr = list_start_addr + MAX_VIRTUAL_PAGE_COUNT_PER_BLOCK_SIZE;

    for i in list_start_addr..list_end_addr {
        let page_addr = MEMORY[i];
        let page_ptr = page_addr as ptr;

        if page_addr == 0 {
            page_ptr = alloc_page();
            MEMORY[i] = page_ptr as int;

            let round_block_size = block_size.next_power_of_4();
            let full_block_size = round_block_size + POINTER_METADATA_SIZE;
            let block_count = (VIRTUAL_PAGE_SIZE - VIRTUAL_PAGE_METADATA_SIZE) / (round_block_size + 1 + POINTER_METADATA_SIZE);
            let stack_start_addr = (page_ptr as int) + VIRTUAL_PAGE_METADATA_SIZE;
            let block_list_start_addr = stack_start_addr + block_count;
            let last_block_addr = block_list_start_addr + (block_count * full_block_size) - round_block_size;

            page_ptr[0] = block_count;
            page_ptr[1] = block_list_start_addr;
            page_ptr[2] = full_block_size;
            page_ptr[3] = block_count;

            for j in 0..block_count {
                MEMORY[stack_start_addr + j] = last_block_addr - (j * full_block_size);
            }
        }

        let offset = page_ptr[0];

        if offset != 0 {
            offset -= 1;
            result = page_ptr[offset + VIRTUAL_PAGE_METADATA_SIZE] as ptr;

            if (result[-1] == 0) {
                // If the pointer is allocated for the first time, assign a random version to it
                result[-1] = get_random_version() << 2;
            }

            result[-1] = set_pointer_state(result[-1] + 4, PointerState::Allocated);
            page_ptr[0] = offset;
            break;
        }
    }

    result
}

// TODO: inline these
fn set_pointer_state(metadata: int, state: PointerState) -> int {
    (metadata & 0xfffffffc) + (state as int)
}

fn get_pointer_state(metadata: int) -> PointerState {
    (metadata & 0x3) as PointerState
}

sys fn trigger_garbage_collection() {
    wasm_retain_globals();

    for i in 0..BLOCK_SIZE_COUNT {
        for j in 0..MAX_VIRTUAL_PAGE_COUNT_PER_BLOCK_SIZE {
            let page_addr = MEMORY[MEMORY_METADATA_ADDR_START + i * MAX_VIRTUAL_PAGE_COUNT_PER_BLOCK_SIZE + j];

            if page_addr == 0 {
                break;
            }

            let page_ptr = page_addr as ptr;
            let block_list_start_addr = page_ptr[1];
            let full_block_size = page_ptr[2];
            let block_count = page_ptr[3];

            for k in 0..block_count {
                let metadata_ptr = block_list_start_addr + (full_block_size * k) as ptr;
                let metadata = metadata_ptr[0];
                let state = get_pointer_state(metadata);

                if state == PointerState::Allocated {
                    let avilable_block_count = page_ptr[0];

                    metadata_ptr[0] = set_pointer_state(metadata, PointerState::Unallocated);
                    page_ptr[avilable_block_count + VIRTUAL_PAGE_METADATA_SIZE] = (metadata_ptr as int) + 1;
                    page_ptr[0] = avilable_block_count + 1;
                } else if state == PointerState::Retained {
                    metadata_ptr[0] = set_pointer_state(metadata, PointerState::Allocated);
                }
            }
        }
    }

    for i in 0..BIG_BLOCK_COUNT {
        let block_ptr = MEMORY[BIG_BLOCKS_METADATA_START + i] as ptr;
        let metadata = block_ptr[1];
        let state = get_pointer_state(metadata);

        if state == PointerState::Allocated {
            block_ptr[1] = set_pointer_state(metadata, PointerState::Unallocated);
        } else if state == PointerState::Retained {
            block_ptr[1] = set_pointer_state(metadata, PointerState::Allocated);
        }
    }
}

sys fn retain_memory(addr: ptr) -> bool {
    let success = false;

    if (addr as int) > 0 {
        let metadata = addr[-1];
        
        if get_pointer_state(metadata) == PointerState::Allocated {
            addr[-1] = set_pointer_state(metadata, PointerState::Retained);
            success = true;
        }
    }

    success
}

// Returns the allocated memory in bytes
sys fn get_memory_usage() -> int {
    let count = 0;

    for i in 0..BLOCK_SIZE_COUNT {
        for j in 0..MAX_VIRTUAL_PAGE_COUNT_PER_BLOCK_SIZE {
            let page_addr = MEMORY[MEMORY_METADATA_ADDR_START + i * MAX_VIRTUAL_PAGE_COUNT_PER_BLOCK_SIZE + j];

            if page_addr == 0 {
                break;
            }

            let page_ptr = page_addr as ptr;
            let block_list_start_addr = page_ptr[1];
            let full_block_size = page_ptr[2];
            let block_count = page_ptr[3];

            for k in 0..block_count {
                let metadata_ptr = block_list_start_addr + (full_block_size * k) as ptr;
                let metadata = metadata_ptr[0];
                let state = get_pointer_state(metadata);

                if state != PointerState::Unallocated {
                    count += full_block_size;
                }
            }
        }
    }

    for i in 0..BIG_BLOCK_COUNT {
        let block_ptr = MEMORY[BIG_BLOCKS_METADATA_START + i] as ptr;
        let block_size = block_ptr[0];
        let metadata = block_ptr[1];
        let state = get_pointer_state(metadata);

        if state != PointerState::Unallocated {
            count += block_size;
        }
    }

    count * MEMORY_CELL_BYTE_SIZE
}

fn alloc_page() -> ptr {
    (wasm_memory_grow(WASM_PAGE_COUNT_PER_VIRTUAL_PAGE) * WASM_PAGE_BYTE_SIZE / MEMORY_CELL_BYTE_SIZE) as ptr
}

fn wasm_memory_grow(page_count: int) -> int {{
    memory.grow
}}

fn wasm_retain_globals() {{
    (call $retain_globals)
}}