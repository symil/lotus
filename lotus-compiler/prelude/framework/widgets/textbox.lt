pub class TextBoxData {
    text: string = "",
    cursor_index: int = 0
}

pub view TextBox {
    get_data: fn(#LOCAL_DATA_TYPE)(TextBoxData),
    placeholder: string = "",
    text_color: Color = Color::black(),
    placeholder_color: Color = Color::gray(),
    background_color: Color = Color::white(),
    on_enter: MouseHandlerCallback = none,

    _get_data() -> TextBoxData {
        (self.get_data)(self.client().local_data)
    }

    @OnRender {
        let data = self._get_data();
        let text = data.text;
        let cursor_index = data.cursor_index;
        let color = self.text_color;
        let border_width = DEFAULT_BORDER_WIDTH;

        if text.is_empty() {
            text = self.placeholder;
            cursor_index = none;
            color = self.placeholder_color;
        }

        self.add_to_focus_chain()
            .background_color(self.background_color)
            .border_color(self.text_color)
            .border_radius(DEFAULT_BORDER_RADIUS)
            .border_width(DEFAULT_BORDER_WIDTH)
            .text_horizontal_align(HorizontalAlign::Left)
            .text_size(.5h)
            .text_color(color)
            .text(text)
            .cursor(Cursor::Text)
            .focus_border_width(border_width.scale(DEFAULT_FOCUSED_BORDER_WIDTH_MULTIPLIER))
            .focus_text_cursor_index(cursor_index)
    }

    @OnPostRender {
        for view in self.client()._all_views {
            view.on_click(() => self.unfocus());
        }

        self.on_click(() => self.focus());
    }

    @OnKeyboardEvent {
        check evt.action == KeyboardAction::Down;
        check self.is_focused();

        let data = self._get_data();
        let ctrl = evt.ctrl_key;

        if evt.code == KeyCode::Escape {
            self.unfocus();
            intercept;
        } else if evt.code == KeyCode::Enter {
            if self.on_enter {
                let callback = (self.on_enter);
                callback(evt.client);
            }
            intercept;
        } else {
            let valid = true;
            let text = data.text;
            let cursor_index = data.cursor_index;

            cursor_index = cursor_index.clamp(0, text.len());

            match evt.code {
                KeyCode::Backspace => {
                    if ctrl {
                        text = text.substring(cursor_index, none);
                        cursor_index = 0;
                    } else {
                        text = text.substring(0, cursor_index - 1) + text.substring(cursor_index, none);
                        cursor_index -= 1;
                    }
                },
                KeyCode::Delete => {
                    if (ctrl) {
                        text = text.substring(0, cursor_index);
                    } else {
                        text = text.substring(0, cursor_index) + text.substring(cursor_index + 1, none);
                    }
                },
                KeyCode::Home => {
                    cursor_index = 0;
                },
                KeyCode::End => {
                    cursor_index = text.len();
                },
                KeyCode::ArrowLeft => {
                    if ctrl {
                        cursor_index = 0;
                    } else {
                        cursor_index -= 1;
                    }
                },
                KeyCode::ArrowRight => {
                    if ctrl {
                        cursor_index = text.len();
                    } else {
                        cursor_index += 1;
                    }
                },
                _ => {
                    if is_valid_character(evt.text) && !ctrl {
                        text = text.substring(0, cursor_index) + evt.text.to_string() + text.substring(cursor_index, text.len());
                        cursor_index += 1;
                    } else {
                        valid = false;
                    }
                }
            }

            if (valid) {
                cursor_index = cursor_index.clamp(0, text.len());
                data.text = text;
                data.cursor_index = cursor_index;
                intercept;
            }
        }
    }
}

const VALID_TEXTBOX_CHARACTERS = ['_', '~', '!', '@', '#', '$', '%', '&', '*', '(', ')', '+', '-', '=', ',', '<', '.', '>', '/', '?', '|'];

fn is_valid_character(c: char) -> bool {
    c && (c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || VALID_TEXTBOX_CHARACTERS.includes(c)
}

// return /^[0-9a-zA-Z_ ~!@#$%&*()+-=,<.>/?|]$/.test(c);