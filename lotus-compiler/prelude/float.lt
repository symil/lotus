export type(f32) float {
    add(float) -> float {{ f32.add }}
    sub(float) -> float {{ f32.sub }}
    mul(float) -> float {{ f32.mul }}
    div(float) -> float {{ f32.div }}
    eq(float) -> bool {{ f32.eq }}
    ne(float) -> bool {{ f32.ne }}
    ge(float) -> bool {{ f32.ge }}
    gt(float) -> bool {{ f32.gt }}
    le(float) -> bool {{ f32.le }}
    lt(float) -> bool {{ f32.lt }}

    as_int() -> int {{ i32.reinterpret_f32 }}
    to_int() -> int {{ i32.trunc_f32_s }}
    to_float() -> float {{ }}

    abs() -> float {{ f32.abs }}
    neg() -> float {{ f32.neg }}
    ceil() -> float {{ f32.ceil }}
    floor() -> float {{ f32.floor }}
    trunc() -> float {{ f32.trunc }}
    round() -> float {{ f32.nearest }}
    sqrt() -> float {{ f32.sqrt }}
    min(float) -> float {{ f32.min }}
    max(float) -> float {{ f32.max }}

    static default() -> float {{
        (f32.const 0)
    }}

    static type_name() -> string {
        return #TYPE_NAME;
    }

    static __none() -> float {{
        (f32.const nan:0x200000)
    }}

    __is_none() -> bool {{
        i32.reinterpret_f32
        (f32.const nan:0x200000)
        i32.reinterpret_f32
        (i32.eq)
    }}

    __hash() -> int {
        return this.as_int().__hash();
    }

    static __chosen() -> float {
        return 18.5f;
    }

    is_nan() -> bool {
        return !(this == this);
    }

    to_string() -> string {
        if this.__is_none() {
            return "none";
        }

        let result = @alloc(16);

        call_float_to_string(this, result);

        return result as string;
    }

    to_debug_string(set: Set<ptr>) -> string {
        if this.__is_none() {
            return "none";
        }

        return this.to_string();
    }

    __retain() {{

    }}

    __serialize(buffer: Buffer) {
        buffer.push(this.as_int());
    }

    static __deserialize(buffer: Buffer) -> float? {
        return buffer.read().as_float();
    }
}

fn call_float_to_string(float, ptr) {{
    (call $float_to_string)
}}